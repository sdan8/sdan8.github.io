<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java文件编码]]></title>
      <url>%2F2016%2F12%2F03%2FJava%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627String s = "张三Ab1";//转换成字节序列用的是项目默认编码(gbk)，等同于 s.getBytes("gbk")byte[] bytes1 = s.getBytes();for(byte b : bytes1)&#123; //byte转换成int，把后8位前面加上24个0，变成32位 //位与上 0xff 去掉前面24个0 System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：d5 c5 c8 fd 41 62 31// 张 三 A b 1//gbk编码中文占2字节，英文占1字节//转换成utf-8编码byte[] bytes2 = s.getBytes("utf-8");for(byte b : bytes2)&#123; System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：e5 bc a0 e4 b8 89 41 62 31//utf-8编码中文占3字节，英文占1字节//Java是双字节编码 utf-16bebyte[] bytes3 = s.getBytes("utf-16be");for(byte b : bytes3)&#123; System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：5f 20 4e 9 0 41 0 62 0 31//utf-16be编码中文英文都占2字节 当字节序列是某种编码时，如果要转换成字符串，也需要用这种编码方式，否则出现乱码，不指明编码方式时用项目默认编码方式。 123456String s = "张三";byte[] bytes = s.getBytes(utf-16be);String str1 = new String(bytes); //用项目默认编码方式（gbk），输出乱码String str2 = new String(bytes,"utf-16be"); //用utf-16be编码，输出正常System.out.print(str1); //输出乱码System.out.print(str2); //输出正常e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript正则表达式笔记]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[RegExp对象两种方法实例化RegExp对象 字面量 构造函数 字面量 将文本写在两个斜线”/“之间 1var reg = /\bis\b/g; 构造函数 使用 new RegExp()出一个对象 12var reg = new RegExp('\\bis\\b','g');// 这里的"\\b"是因为转义字符。 修饰符 g:global全文搜索，不添加，搜索到第一个匹配停止，默认false i:ignore case忽略大小写，默认大小写敏感，默认false m:multiple lines多行搜索，默认false 元字符 正则表达式由两种基本字符类型组成: 原义文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符* + ? $ ^ . | \ ( ) { } [ ] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX 与X对应的控制字符（Ctrl+X） 字符类 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符 字符类取反 使用元字符 ^ 创建 反向类/负向类 反向类的意思是不属于某类的内容 表达式 [^abc] 表示不是字符a或b或c的内容 范围类 可以使用 [a-z] 来连接两个字符表示从a到z的任意字符 这是一个闭区间，包含a和z本身 在 [] 组成的类内部是可以连写的 [a-zA-Z] 预定义类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 digit \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 space \S [^\t\n\x0B\f\r] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字下划线） word \W [^a-zA-Z_0-9] 非单词字符 匹配一个 ab+数字+任意字符 的字符串ab\d. 边界 字符 含义 ^ 以xxx开始 $ 以xxx结束 \b 单词边界 \B 非单词边界 量词 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式\d{3,6} 匹配最多的6次‘123456789’.replace(/\d{3,6}/g, ‘X’) 结果为 “X789” 非贪婪模式在量词后加上 ? 即可‘123456789’.match(/\d{3,5}?/g) 结果为 [“123”,”456”,”789”]‘12345678’.replace(/\d{3,6}?/g, ‘X’) 结果为 “XX78” 分组 Byron连续出现3次：Byron{3}含义为 “Byro” “n”重复3次两次作用于紧挨着的 “n” 使用()可以达到分组的功能，使两次作用于分组(Byron){3} 即可 或 使用 | 可达到或的效果Byr(on|Ca)sper 匹配on或者Ca 反向引用 2015-12-25 =&gt; 12/25/2015‘2015-12-25’.replace(/(\d{4})-(\d{2})-(\d{2})/g, ‘$2/$3/$1’) 忽略分组 不希望捕获某些分组，只需要在分组内加上 ?: 就可以(?:Byron).(ok)这时的 $1 为 ok 前瞻 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前” 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反 JavaScript不支持后顾 符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配 名称 正则 含义 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向后顾 exp(?&lt;=assert) JavaScript不支持 负向后顾 exp(?&lt;!assert) JavaScript不支持 正向前瞻‘a234v8’.replace(/\w(?=\d)/g, ‘X’) 结果为 “X2X4X8”‘a234vv’.replace(/\w(?=\d)/g, ‘X’) 结果为 “X2X4vv” 负向前瞻‘a234vv’.replace(/\w(?!\d)/g, ‘X’) 结果为 “aX3XXX” 对象属性 这几个属性是只读的 global:全文搜索，不添加，搜索到第一个匹配停止，默认false ignore case:忽略大小写，默认大小写敏感，默认false multiline:多行搜索，默认false lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置 source:正则表达式的文本字符串 RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在返回true，否则返回false 12345var reg1 = /\w/;var reg2 = /\w/g;reg1.test('a'); //执行多次结果均为truereg2.test('a'); //执行多次结果为true,false,true,false... 当加上g之后，每次搜索会影响到lastIndex属性的值，会从lastIndex开始 RegExp.prototype.exec(str) 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符的位置 input 存放被检索的字符串 string 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式（就是分组）相匹配的文本（如果有的话） 第三个元素是与RegExp对象的第二个子表达式（就是分组）相匹配的文本（如果有的话），依此类推 String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果index，查找不到返回 -1 search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索 String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与RegExp相匹配的文本 regexp是否具有标志g对结果影响很大 非全局调用 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性 index 声明匹配文本的起始字符在字符串的位置 input 声明对stringObject的引用 全局调用 如果regexp具有标志g则match()方法将执行全局检索，找到字符串中的所有匹配子字符串 没有找到任何匹配的子串，则返回null 如果找到了一个或多个匹配子串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 String.prototype.split(reg) 我们经常使用split方法把字符串分割为字符数组 ‘a,b,c,d’.split(‘,’); //[“a”,”b”,”c”,”d”] 在一些复杂的分割情况下我们可以使用正则表达式解决 ‘a1b2c3d’.split(/\d/); //[“a”,”b”,”c”,”d”] String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function参数含义 function会在每次匹配替换的时候调用，有四个参数 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的index 原字符串 ‘a1b2c3d4e5’ =&gt; ‘a2b3c4d5e6’123'a1b2c3d4e5'.replace(/\d/g, function(match,index,origin)&#123; return parseInt(match) + 1;&#125;); ‘a1b2c3d4e5’ =&gt; ‘a12c34e5’ 去掉\d\w\d中的\w123'a1b2c3d4e5'.replace(/(\d)(\w)(\d)/, function(match,group1,group2,group3,index,origin)&#123; return group1 + group3;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记（二）]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[定义数组123456789101112131415var myarr1 = new Array();var myarr2 = new Array(5); //虽然指定长度，但是可以增加var myarr3 = new Array(10,20,30,40,50);var myarr4 = [10,20,30,40,50]; //直接输入一个数组（称“字面量数组”）//声明二维数组方法一var myarr = new Array();for(var i=0;i&lt;2;i++)&#123; myarr[i] = new Array(); for(var j=0;j&lt;3;j++) &#123; myarr[i][j]=i+j; &#125;&#125;var myArr = [[0,1,2],[3,4,5]]//声明二维数组方法二 事件主要事件表 事件 说明 onclick 鼠标单击事件 onmouseover 鼠标经过事件 onmouseout 鼠标移开事件 onchange 文本框内容改变事件 onselect 文本框内容被选中事件 onfocus 光标聚集 onblur 光标离开 onload 网页导入 写在body标签内 onunload 关闭网页 日期对象Date常用方法 方法名称 功能描述 get/setDate() 返回/设置日期 get/setFullYear() 返回/设置年份，用四位数表示 get/setYear() 返回/设置年份 get/setMonth() 返回/设置月份。0:一月…11:十二月 get/setHours() 返回/设置小时，24小时制 get/setMinutes() 返回/设置分钟数 get/setSeconds() 返回/设置秒钟数 get/setTime() 返回/设置时间（毫秒为单位） getDay() 返回星期，返回的是数字，0表示星期天 字符串对象Stringlength属性:返回字符串长度 方法名称 功能描述 参数描述 toUpperCase() 转换为大写 toLowerCase() 转换为小写 charAt(index) 返回指定位置的字符 整型，下标，从0开始 indexOf(substring, startpos) 返回指定字符串值在字符串中首次出现的位置 substring:字符串，必需，规定需检索的字符串。startpos:整型，规定开始检索的位置，从0到length-1之间，省略则从0开始 split(separator,limit) 分割为字符串数组，并返回此数组 separator:字符串，必需，从指定地方开始分割。limit:整型，分割次数，如果无此参数则不限制次数 substring(starPos,stopPos) 提取字符串中两个指定下标之间的字符 startPos:整型，必需，开始位置。stopPos:整型，可选，结束位置 substr(startPos,length) 提取字符串中从开始位置的指定数目的字符串 startPos:整型，必需，开始位置，如果为负数则倒数，-1是最后一个字符，-2是倒数第二个。length:整型，可选，字符串长度 Math对象内置对象，直接使用 属性 说明 E 返回算术常量e，即自然对数的底数（约等于2.718） LN2 返回2的自然对数（约等于0.693） LN10 返回10的自然对数（约等于2.302） LOG2E 返回以2为底的e的对数（约等于1.442） LOG10E 返回以10为底的e的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回2的平方根的倒数（约等于0.707） SQRT2 返回2的平方根（约等于1.414） 方法 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 返回数的反正切值 atan2(y,x) 返回由x轴到点(x,y)的角度（以弧度为单位） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回e的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回x和y中的最高值 min(x,y) 返回x和y中的最低值 pow(x,y) 返回x的y次幂 random() 返回0~1之间的随机数 [0,1) round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 toSource() 返回该对象的源代码 valueOf() 返回Math对象的原始值 数组对象 方法 描述 concat(arr1,arr2,…,arrN) 连接两个或更多的数组，并返回一个新数组 join(separator) 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分割，参数省略则用逗号分割 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 颠倒数组中元素的顺序 shift() 删除并返回数组的第一个元素 slice(start,end) 从某个已有的数组返回选定的元素 sort(方法函数) 对数组的元素进行排序，如果不指定&lt;方法函数&gt;，则按Unicode码顺序排列 splice() 删除元素，并像数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串，并返回结果 toLocaleString() 把数组转换为本地数组，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值 sort()使用说明 比较函数具有两个参数A和B，返回值如下： 若返回值 (-无穷,-1]，则表示A在排序后的序列中出现在B之前 若返回值 (-1,1)，则表示A和B具有相同的排序顺序 若返回值 [1,+无穷)，则表示A在排序后的序列中出现在B之后 12345678910//不带参数&lt;script type="text/javascript"&gt; var myarr1 = new Array("Hello","John","love","Javascript"); var myarr2 = new Array("80","16","50","6","100","1"); document.write(myarr1.sort() + "&lt;br /&gt;"); document.write(myarr2.sort()); //运行结果 //Hello,JavaScript,John,love //1,100,16,50,6,80&lt;/script&gt; 1234567891011121314//带参数&lt;script type="text/javascript"&gt; function sortNum(a,b) &#123; return a - b; //升序，如降序，改为"b - a" &#125; var myarr = new Array("80","16","50","6","100","1"); document.write(myarr + "&lt;br /&gt;"); document.write(myarr.sort(sortNum)); //运行结果 //80,16,50,6,100,1 //1,6,16,50,80,100&lt;/script&gt; window对象 方法 描述 参数描述 示例 alert() 显示带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open([URL],[窗口名称],[参数字符串]) 打开一个新的浏览器窗口或查找一个已命名的窗口 具体用法见JavaScrip基础篇学习笔记 close() 关闭浏览器窗口 print() 打印当前窗口的内容 focus 把键盘焦点给予一个窗口 blur() 把键盘焦点从顶层窗口移开 moveBy() 可相对窗口的当前坐标把它移动指定的像素 moveTo() 把窗口的左上角移动到一个指定的坐标 resizeBy() 按照指定的像素调整窗口的大小 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素值来滚动内容 scrollTo() 把内容滚动到指定的坐标 setInterval(代码,交互时间) 每隔指定的时间执行代码 代码：要调用的函数或要执行的代码串。交互时间：以毫秒计 setInterval(“clock()”,1000);或setInterval(clock,1000); setTimeout(代码,延迟时间) 在指定的延迟时间之后来执行代码 代码：要调用的函数或要执行的代码串。延迟时间:执行代码前等待的时间，毫秒计 clearInterval(id_of_setInterval) 取消setInterval()的设置 id_of_setInterval:由setInterval()返回的ID值 var i = setInterval(“clock()”, 1000); clearInterval(i); clearTimeout(id_of_setTimeout) 取消setTimeout()的设置 id_of_setInterval:由setTimeout()返回的ID值 History对象语法12window.history.[属性|方法]//window可以省略 属性 属性 描述 length 返回浏览器历史列表中的URL数量 方法 方法 描述 备注 back() 加载history列表中的前一个URL 相当于history.go(-1) forward() 加载history列表中的下一个URL 相当于history.go(1) go(number) 加载history列表中的某个具体的页面 0为当前页面,其他数值为history的URL列表中的相对位置 Location对象语法1location.[属性|方法] 属性 设URL为：http://www.imooc.com:8080/list.php?courseid=8#mediaid118 属性 描述 属性对应内容 hash 设置或返回从井号(#)开始的URL(锚) mediaid118 host 设置或返回主机名和当前URL的端口号 www.imooc.com:8080 hostname 设置或返回当前URL的主机名 www.imooc.com href 设置或返回完整的URL http://www.imooc.com:8080/list.php?courseid=8#mediaid118 pathname 设置或返回当前URL的路径部分 list.php port 设置或返回当前URL的端口号 8080 protocol 设置或返回当前URL的协议 http: search 设置或返回从问号(?)开始的URL(查询部分) courseid=8 方法 属性 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 Navigator对象属性 属性 描述 appCodeName 浏览器代码名的字符串表示 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent头部的值 screen对象语法1window.screen.属性 对象属性 属性 描述 availHeight 窗口可以使用的屏幕高度，单位像素 availWidth 窗口可以使用的屏幕宽度，单位像素 colorDepth 用户浏览器表示的颜色位数，通常为32位(每像素的位数) pixelDepth 用户浏览器表示的颜色位数，通常为32位(IE不支持此属性) height 屏幕分辨率的高度，单位像素 width 屏幕分辨率的宽度，单位像素 文档对象模型DOM(Document Object Model)DOM节点有： 元素节点：&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等，即标签。 文本节点：向用户展示的内容。 属性节点：元素属性。 节点属性 方法 说明 nodeName 返回一个字符串，其内容是给定节点的名字。 nodeType 返回一个整数，这个数值代表给定节点的类型 nodeValue 返回给定节点的当前值 nodeName属性：节点的名称，是只读的。 元素节点的nodeName与标签名相同 属性节点的nodeName是属性的名称 文本节点的nodeName永远是#text 文档节点的nodeName永远是#document nodeValue属性：节点的值 元素节点的nodeValue是undefined或null 文本节点的nodeValue是文本自身 属性节点的nodeValue是属性的值 nodeType属性：节点的类型，是只读的。以下常用几种节点类型： 元素：1 属性：2 文本：3 注释：4 文档：5 遍历节点树 方法 说明 备注 childNodes 返回一个数组，这个数组由给定元素节点的子节点构成。 firstChild 返回第一个子节点，没有子节点则返回null 与childNodes[0]等同 lastChild 返回最后一个子节点，没有子节点则返回null 与childNodes[childNodes.length-1]等同 parentNode 返回一个给定节点的父节点 nextSibling 返回给定节点的下一个子节点 previousSibling 返回给定节点的上一个子节点 DOM操作 方法 说明 createElement(element) 创建一个新的元素节点 createTextNode() 创建一个包含着给定文本的新文本节点 appendChild() 指定节点的最后一个子节点列表之后添加一个新的子节点 insertBefore() 将一个给定节点插入到一个给定元素节点的给定子节点的前面 removeChild() 从一个给定元素中删除一个子节点 replaceChild() 把一个给定父元素里的一个子节点替换为另外一个子节点 getElementsByName()方法语法 1document.getElementsByName(name); 注意 因为文档中name属性可能不唯一，所以getElementsByName()方法返回的元素是数组，而不是一个元素。 和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。 getElementsByTagName()方法语法 1document.getElementsByTagName(Tagname); 说明 Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 getAttribute()方法语法 1elementNode.getAttribute(name); 说明 elementNode:使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。 name:要想查询的元素节点的属性名字。 setAttribute()方法语法 1elementNode.setAttribute(name,value); 说明 name:要设置的属性名 value:要设置的属性值 注意 把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 访问子节点childNodes语法 1elementNode.childNodes; 注意 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 示例 12345678910&lt;ul&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;jQuery&lt;/li&gt; &lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var x=document.getElementsByTagName("ul")[0].childNodes; document.write("UL子节点个数："+x.length+"&lt;br /&gt;"); document.write("节点类型："+x[0].nodeType);&lt;/script&gt; 运行结果： IE： 12UL子节点个数：3节点类型：1 其它浏览器： 12UL子节点个数：7节点类型：3 注意 IE全系列、firefox、chrome、opera、safari兼容问题 节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7 12345&lt;ul&gt;&lt;!--空白节点--&gt; &lt;li&gt;javascript&lt;/li&gt;&lt;!--空白节点--&gt; &lt;li&gt;jQuery&lt;/li&gt;&lt;!--空白节点--&gt; &lt;li&gt;PHP&lt;/li&gt;&lt;!--空白节点--&gt;&lt;/ul&gt; 如果把代码改成这样 1&lt;ul&gt;&lt;li&gt;javascript&lt;/li&gt;&lt;li&gt;jQuery&lt;li&gt;&lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt; 运行结果：（IE和其它浏览器结果是一样的） 12UL子节点个数：3节点类型：1 firstChild和lastChild firstChild等同于elementNode.childNodes[0] lastChild等同于elementNode.childNodes[elementNode.childNodes.length-1] 如果没有子节点则返回null parentNode父节点只能有一个 语法 1elementNode.parentNode 访问兄弟节点 nextSibling属性可返回某个节点之后紧跟的节点 1nodeObject.nextSibling previousSibling属性可返回某个节点之前紧跟的节点 1nodeObject.previousSibling 注意 两个属性获取的是节点。Internet Explorer会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。 解决问题方法：判断节点nodeType是否为1 插入节点appendChild()语法 1appendChild(newnode) 示例 1234567&lt;div id="test"&gt;&lt;p id="x1"&gt;HTML&lt;/p&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest = document.getElementById("test"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; otest.appendChild(newnode);&lt;/script&gt; 插入节点insertBefore()语法 1insertBefore(newnode,node); 参数 newnode:要插入的新节点 node:指定此节点前插入节点 123456789&lt;div id="test"&gt;&lt;p id="x1"&gt;HTML&lt;/p&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest = document.getElementById("test"); var node = document.getElementById("x1"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; otest.insertBefore(newnode,node); //或者otest.insertBefore(newnode,otest.childNodes[0]);&lt;/script&gt; 删除节点removeChild()如删除成功，则返回被删除的节点，如失败，则返回NULL 语法 1nodeObject.removeChild(node) 示例 123456&lt;div id="div1"&gt;&lt;h1&gt;HTML&lt;/h1&gt;&lt;h2&gt;javascript&lt;/h2&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest=document.getElementById("div1"); var x=otest.removeChild(otest.childNodes[1]); document.write("删除节点的内容："+x.innerHTML);&lt;/script&gt; 注意 把删除的子节点赋值给x，这个子节点不在DOM树中，但是还存在内存中，可通过x操作如果要完全删除对象，给x赋值null值。 替换元素节点replaceChild()replaceChild实现子节点（对象）的替换。返回被替换对象的引用 语法1node.replaceChild(newnode,oldnew) 参数 newnode:必需，用于替换oldnew对象 oldnew:必需，被newnode替换的对象。 示例 123456789101112&lt;script type="text/javascript"&gt; function replaceMessage() &#123; var newnode=document.createElement("p"); var newnodeText=document.createTextNode("JavaScript"); newnode.appendChild(newnodeText); var oldNode=document.getElementById("oldnode"); oldNode.parentNode.replaceChild(newnode,oldNode); &#125;&lt;/script&gt;&lt;h1 id="oldnode"&gt;Java&lt;/h1&gt;&lt;a href="javascript:replaceMessage()"&gt;"Java"改为"JavaScript"&lt;/a&gt; 注意 当oldnode被替换时，所有与之相关的属性内容都将被移除 newnode必须先被建立 创建元素节点createElementcreateElement()方法可创建元素节点。此方法可返回一个Element对象 语法 1document.createElement(tagName) 参数 tagName:字符串值，这个字符串用来指明创建元素的类型 注意 要与appendChild()或insertBefore()方法联合使用，将元素显示在页面中 创建文本节点createTextNodecreateTextNode()方法创建新的文本节点，返回新创建的Text节点 语法 1document.createTextNode(data) 参数 data:字符串值，可规定此节点的文本 浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera以及Safari: window.innerHeight:浏览器窗口的内部高度 window.innerWidth:浏览器窗口的内部宽度 对于Internet Explorer8、7、6、5: document.documentElement.clientHeight表示HTML文档所在窗口的当前高度 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度 或者 Document对象的body属性对应HTML文档的&lt;body&gt;标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的JavaScript方案： 12var w = document.documentElement.clientWidth || document.body.clientWidth;var h = document.documentElement.clientHeight || document.body.clientHeight; 网页尺寸scrollHeightscrollHeight和scrollWidth，获取网页内容高度和宽度 针对IE、Opera： scrollHeight是网页内容实际高度，可以小于clientHeight。 针对NS、FF: scrollHeight是网页内容高度，不过最小值是clientHeight。也就是说网页内容实际高度小于clientHeight时，scrollHeight返回clientHeight。 浏览器兼容性12var w = document.documentElement.scrollWidth || document.body.scrollWidth;var h = document.documentElement.scrollHeight || document.body.scrollHeight; scrollHeight和scrollWidth还可获取DOM元素中内容实际占用的高度和宽度 网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度（包括滚动条等边线，会随窗口的显示大小改变） 值 offsetHeight = clientHeight + 滚动条 + 边框 浏览器兼容性 12var w = document.documentElement.offsetWidth || document.body.offsetWidth;var h = document.documentElement.offsetHeight || document.body.offsetHeight; 网页卷去的距离与偏移量 scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由offsetParent属性指定的父坐标的计算左侧位置。 offsetTop:获取指定对象相对于版面或由offsetParent属性指定的父坐标的计算顶端位置。 注意 offsetParent:布局中设置position属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记（一）]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[保留字和关键字 关键字 break else new var case finally return void catch for switch while default if throw delete in try do instanceof typeof 保留字 abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 输出1document.write("输出的内容"); 消息对话框123alert(str); //一个确定按钮confirm(str);//确定，取消按钮,返回值为用户选择prompt(str1,str2);//确定，取消，输入框 窗口操作打开新窗口1window.open([URL],[窗口名称],[参数字符串]); URL：在窗口中要显示的路径 窗口名称： “_top”,”_blank”,”_self”这三个具有特殊意义，其余按正常命名规则取名。 _top:框架网页中在上部窗口中显示目标网页 _blank:在新窗口中显示目标网页 _self:在当前窗口显示目标网页 参数表 参数 值 说明 top Number 窗口顶部离开屏幕顶部的像素数 left Number 窗口左端离开屏幕左端的像素数 width Number 窗口的宽度 heitht Number 窗口的高度 menubar yes,no 窗口有没有菜单 toolbar yes,no 窗口有没有工具条 scrollbars yes,no 窗口有没有滚动条 status yes,no 窗口有没有状态栏 关闭窗口close()关闭窗口 用法： 12window.close(); //关闭本窗口&lt;窗口对象&gt;.close();//关闭指定的窗口 获取元素通过ID获取语法：1document.getElementById("id"); innerHTML属性用于获取或者替换HTML元素的内容。 语法： Object.innerHTML Object是通过document.getElementById(“id”)获取到的元素 注： innerHTML:从对象起始位置到终止位置的全部内容，包括HTML标签innerText:将innerHTML去除HTML标签outerHTML:除了innerHTML的内容外，还包含对象本身的标签特别：innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器，因此，尽可能地去使用innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：&lt;a href=&quot;javascript:alert(document.getElementById(&#39;test&#39;).innerHTML.replace(/&lt;.+?&gt;/gim,&#39;&#39;))&quot;&gt;无HTML,符合W3C标准&lt;/a&gt; 改变HTML样式语法：1Object.style.property = new style; 基本属性（property）：backgroundColor，height，width，color，font，fontFamily，fontSize等等 示例： 1myObject.style.color="red"; 显示和隐藏（display属性）语法：1Object.style.display = value; value的取值： 值 描述 none 此元素不会被显示（即隐藏） block 此元素将显示为块级元素（即显示） 示例：12myObject.style.display = "none"; //隐藏myObject.style.display = "block"; //显示 控制类名（className属性）语法：1Object.className = value; //value为class名 removeAttribute()删除之前应用的样式属性 语法：1Object.removeAttribute("style");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM生成XML文件]]></title>
      <url>%2F2016%2F12%2F03%2FDOM%E7%94%9F%E6%88%90XML%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[与JavaScrip中对DOM文档操作简直一毛一样 12345678910public DocumentBuilder getDocumentBuilder()&#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = null; try &#123; db = dbf.newDocumentBuilder(); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; return db;&#125; 123456789101112131415161718192021222324252627282930313233public void createXML()&#123; DocumentBuilder db = getDocumentBuilder(); Document document = db.newDocument(); //将XML文件第一行中的standalone="yes"，默认不显示 document.setXmlStandalone(true); //创建根节点 Element bookstore = document.createElement("bookstore"); //创建子节点 Element book = document.createElement("book"); //添加属性 book.setAttribute("id", "1"); Element name = document.createElement("name"); //添加文本 name.setTextContent("小王子"); book.appendChild(name); bookstore.appendChild(book); //将已经包含book节点的的bookstore节点添加到DOM树中 document.appendChild(bookstore); TransformerFactory tff = TransformerFactory.newInstance(); try &#123; Transformer tf = tff.newTransformer(); //换行 tf.setOutputProperty(OutputKeys.INDENT, "yes"); tf.transform(new DOMSource(document), new StreamResult(new File("books1.xml"))); &#125; catch (TransformerConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (TransformerException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM解析XML]]></title>
      <url>%2F2016%2F12%2F03%2FDOM%E8%A7%A3%E6%9E%90XML%2F</url>
      <content type="text"><![CDATA[四种解析方式 DOM SAX DOM4J JDOM 常用的节点类型 节点类型 NodeType Named Constant nodeName的返回值 nodeValue的返回值 Element 1 ELEMENT_NODE element name null Attr 2 ATTRIBUTE_NODE 属性名称 属性值 Text 3 TEXT_NODE #text 节点内容 DOM方式解析XML步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void main(String[] args) &#123; //创建一个DocumentBuilderFactory对象 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); try &#123; //创建DocumentBuilder对象 DocumentBuilder db = dbf.newDocumentBuilder(); //通过DocumentBuilder对象的parse方法加载books.xml文件到当前项目下 Document document = db.parse("books.xml"); //获取所有book节点的集合 NodeList bookList = document.getElementsByTagName("book"); //通过NodeList的getLength()方法可以获取bookList的长度 System.out.println("一共有" + bookList.getLength() + "本书"); //遍历每一个book节点 for(int i = 0; i &lt; bookList.getLength(); i++)&#123; System.out.println("===下面开始遍历第" + (i+1) + "本书的内容==="); //通过item(index)方法获取一个book节点，NodeList索引值从0开始 Node book = bookList.item(i); //获取book节点的所有属性集合 NamedNodeMap attrs = book.getAttributes(); System.out.println("第" + (i+1) + "本书共有" + attrs.getLength() + "个属性"); //遍历book的属性 for(int j = 0; j &lt; attrs.getLength(); j++)&#123; //通过item(index)方法获取book节点某一个属性 Node attr = attrs.item(j); //获取属性名 System.out.print("属性名：" + attr.getNodeName()); //获取属性值 System.err.println("--属性值：" + attr.getNodeValue()); &#125; /*//前提：已经知道book节点有且只能有1个id属性 //将book节点进行强制类型转换，转换成Element类型 Element book = (Element)bookList.item(i); //通过getAttribute("id")方法获取属性值 String attrVal = book.getAttribute("id"); System.out.println("id的属性值为：" + attrVal);*/ //解析book节点的子节点 NodeList childNodes = book.getChildNodes(); //遍历childNodes获取每个节点的节点名和节点值 System.out.println("第" + (i+1) + "本书共有" + childNodes.getLength() + "个子节点"); for(int k = 0; k &lt; childNodes.getLength(); k++)&#123; //区分出text类型的node以及element类型的node if(childNodes.item(k).getNodeType() == Node.ELEMENT_NODE)&#123; //获取了element类型的节点名 System.out.print("第" + (k+1) + "个节点的节点名：" + childNodes.item(k).getNodeName()); //获取了element类型的节点值// System.out.println("--节点值：" + childNodes.item(k).getFirstChild().getNodeValue()); System.out.println("--节点值：" + childNodes.item(k).getTextContent()); &#125; &#125; System.out.println("===下面结束遍历第" + (i+1) + "本书的内容==="); &#125; &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#字符串类型转换]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[string 类型转成 byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes(str); byte[] 转成 string1string str = System.Text.Encoding.Default.GetString(byteArray); string 类型转成 ASCII byte[] (“01” 转成 byte[] = new byte[]{0x30,0x31}) 1byte[] byteArray = System.Text.Encoding.ASCII.GetBytes(str); ASCIIbyte[] 转成 string** (byte[] = new byte[]{0x30,0x31} 转成 “01”) 1string str = System.Text.Encoding.ASCII.GetString(byteArray); byte[] 转16进制格式 string new byte[]{0x30,0x31} 转成 “3031” 1234567891011121314public static string ToHexString(byte[] bytes) //0xae00cf =&gt; "AE00CF"&#123; string hexString = string.Empty; if(bytes != null) &#123; StringBuilder strB = new StringBuilder(); for(int i = 0; i &lt; bytes.Length; i++) &#123; strB.Append(bytes[i].ToString("x2")); &#125; hexString = strB.ToString(); &#125; return hexString;&#125; 16进制格式 string 转 byte[]123456789101112131415161718192021222324252627282930public static byte[] GetBytes(string hexString, out int discarded)&#123; discarded = 0; string newString = ""; char c; //remove all none A-F, 0-9, characters for(int i = 0; i &lt; hexString.Length; i++) &#123; c = hexString[i]; if(IsHexDig(c)) new String += c; else discarded++; &#125; //if odd number of characters,discard last character if(newString.Length % 2 != 0) &#123; discarded++; newString = newString.Substring(0, newString.Length - 1); &#125; int byteLength = newString.Length / 2; byte[] bytes = new byte[byteLength]; string hex; int j = 0; for(int i = 0; i &lt; bytes.Length; i++) &#123; hex = new String(new Char[]&#123;newString[j], newString[j + 1]&#125;); bytes[i] = HexToByte(hex); j = j + 2; &#125; return bytes;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#托盘操作]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E6%89%98%E7%9B%98%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[最小化到托盘 添加 NotifyIcon 控件 设置 NotifyIcon 控件的 Icon 属性，用来显示托盘区的图标 代码部分 12345678910111213141516171819private void Form1_Resize(object sender, EventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Hide(); this.ShowInTaskbar = false; this.notifyIcon1.Visible = true; &#125;&#125;private void notifyIcon1_MouseDoubleClick(object sender, MouseEventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Show(); this.ShowInTaskbar = true; this.notifyIcon1.Visible = false; &#125;&#125; 托盘区右键菜单栏 添加 ContextMenuStrip 控件 添加项 设置菜单项的事件 将 ContextMenuStrip 控件绑定到 NotifyIcon 控件上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剪贴板复制粘贴操作]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[复制12string str = "要复制的内容";Clipboard.SetDataObject(str); 粘贴12345IDataObject ido = Clipboard.GetDataObject();if(ido.Data.GetDataPresent(DataFormats.Text))&#123; txt_content.Text = (String)ido.GetData(DataFormats.Text);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象序列化和反序列化]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[对象序列化和反序列化 对象序列化就是将Object转换成byte序列，反之叫反序列化 序列化流ObjectOutputStream是过滤流—-writeObject(obj) 反序列化流ObjectInputStream—readObject() 要序列化的对象必须实现序列化接口，才能进行序列化，否则将出现异常，这个接口没有任何方法，只是一个标准 被transient关键字修饰的变量，不会进行jvm默认的序列化，但可以自己完成这个元素的序列化 private transient int sutAge; 参考ArrayList类中被transient修饰变量的序列化实现，可理解transient的作用，提高性能，避免无效元素的序列化 如果一个类实现了序列化接口，那么其子类都可以进行序列化 序列化子类对象时，父类和子类的构造函数会被调用 反序列化子类对象时，没有实现序列化接口的父类会调用构造函数，实现了序列化接口的父类不会调用 要序列化的对象12345678910111213141516171819202122232425262728public class Student implements Serializable&#123; private String stuName; private String stuId; private int stuAge; //无参构造方法 public Student()&#123; &#125; //带参构造方法 public Student(String stuName, String stuId, int stuAge) &#123; super(); this.stuName = stuName; this.stuId = stuId; this.stuAge = stuAge; &#125; //get和set方法 public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; //...省略 //toString()方法 @Override public String toString() &#123; return "Student [stuName=" + stuName + ", stuId=" + stuId + ", stuAge=" + stuAge + "]"; &#125;&#125; 序列化实现12345678910111213141516public static void main(String[] args)throws Exception &#123; Student stu = new Student("张三", "10010", 20); String file = "ObjSeria.dat"; //序列化 /*ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(file)); oos.writeObject(stu); oos.flush(); oos.close();*/ //反序列化 ObjectInputStream ois = new ObjectInputStream( new FileInputStream(file)); Student stu1 = (Student)ois.readObject(); System.out.println(stu1); ois.close();&#125; 序列化和反序列化被transient关键字修饰的变量12345678910111213//将这两个方法放入要序列化的类中private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; s.defaultWriteObject();//把jvm能默认序列化的元素进行序列化操作 s.writeInt(stuAge);//自己完成stuAge的序列化&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException&#123; s.defaultReadObject();//把jvm能默认反序列化的元素进行反序列化操作 this.stuAge = s.readInt();//自己完成stuAge的反序列化&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F03%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
