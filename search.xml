<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[配置本地用户访问的FTP服务器]]></title>
      <url>%2F2018%2F12%2F18%2F%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E7%9A%84FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[配置一台仅支持本地用户访问的FTP服务器，并且限制用户访问目录，添加登录时的欢迎信息。 本地环境 虚拟机：VMware® Workstation 14 Pro 服务器操作系统：CentOS 7 客户端：Windows 8 准备工作 参考 简单配置匿名FTP服务器 中准备工作一节。 创建用户创建用于测试的本地用户，登录FTP服务器时就使用这些用户进行登录，如果已有用户可跳过这一小节。创建用户命令 useradd [参数] 用户名 123456useradd -s /sbin/nologin user1 //创建没有登录系统权限的用户user1passwd user1 //设置user1的密码useradd -s /sbin/nologin user2 //创建没有登录系统权限的用户user2passwd user2 //设置user2的密码useradd -s /sbin/nologin user3 //创建没有登录系统权限的用户user3passwd user3 //设置user3的密码 设置本地用户访问打开 /etc/vsftpd/vsftpd.conf 文件，找到相应字段进行设置，配置内容如下： 12anonymous_enable=NO #不允许匿名用户访问local_enable=YES #允许本地用户访问 通过设置 anonymous_enable 字段值为 NO 禁止匿名用户访问，再通过设置 local_enable 字段值为 YES 允许本地用户访问。 启动服务器进行验证，不可以匿名访问服务器，并且可以使用之前新建好的用户进行登录。 限制用户访问目录打开 /etc/vsftpd/vsftpd.conf 文件，找到相应字段进行设置，配置内容如下： 1chroot_local_user=YES #将本地用户锁定在自己的主目录中 通过设置 chroot_local_user 字段值为 YES ，使本地用户登录到FTP服务器时，只能访问自己的主目录，即 /home/用户名 目录，不可以访问到其他目录。但此时该用户不能具有自己主目录的写权限，如果具有自己主目录的写权限，在登录时会报错。 如下图所示，通过 ls -l 命令查看目录权限。 当使用该用户访问服务器时会出现以下提示： 解决这种情况有两种方法： 使用 chmod 500 /home/用户名 去掉用户主目录的写权限。 在配置文件中加入 allow_writeable_chroot=YES 字段。 此时可以使用该用户正常登录服务器。 设置例外用户如果需要有例外的用户，不受到 chroot_local_user 字段的限制，使其能访问到其他目录，可以进行如下设置。 设置配置文件12chroot_list_enable=YES #允许有例外用户chroot_list_file=/etc/vsftpd/chroot_list #设置例外用户列表文件 首先设置 chroot_list_enable 字段值为 YES ，表示允许有例外用户。其次设置 chroot_list_file 字段，值为例外用户列表文件的完整路径。这个列表文件里面写着例外的用户名，服务器通过这个文件判断例外的用户是哪些。 创建例外用户列表文件如果没有例外用户文件，则需要手动创建，命令如下： 1touch /etc/vsftpd/chroot_list 打开该文件，里面填入例外的用户名，一行一个用户。 这里填入两个用户 user1 和 user3 ，表示这两个用户可以访问其他目录，不会被限制在自己主目录中。 重启服务器，登录验证 可以看到，使用 user1 和 user3 都可以访问到其他目录，而 user2 用户只能访问到自己的主目录。 设置欢迎信息设置配置文件12dirmessage_enable=YES #开启登录欢迎信息message_file=/home/welcome #信息提示文件位于/home/welcome 这里的欢迎信息文件可以随意设置。 创建欢迎信息文件如果没有欢迎信息文件，需要手动创建，命令如下： 1touch /home/welcome 打开该文件，在里面填入欢迎信息，随意填写。 重启服务器，登录验证]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单配置匿名FTP服务器]]></title>
      <url>%2F2018%2F12%2F18%2F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8C%BF%E5%90%8DFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[配置一台可以匿名访问的FTP服务器。 本地环境 虚拟机：VMware® Workstation 14 Pro 服务器操作系统：CentOS 7 客户端：Windows 8 准备工作安装vsftp1yum install vsftpd -y 关闭防火墙1systemctl stop firewalld //关闭防火墙 关闭SELinux两种方法： 临时关闭，使用 setenforce 命令实现，但是这种方法在重启系统后失效。 1setenforce 0 通过修改配置文件的方式，使SELinux不随开机启动。打开 /etc/selinux/config 文件，修改 SELINUX 字段值为 disabled ，保存后重启系统生效。 1SELINUX=disabled #完全禁止SELinux的功能 设置配置文件打开 /etc/vsftpd/vsftpd.conf 文件，找到相应字段进行设置，配置内容如下： 1234anonymous_enable=YES #允许匿名用户访问anon_upload_enable=YES #匿名用户可以上传文件anon_mkdir_write_enable=YES #允许匿名用户拥有新建文件夹的权限anon_other_write_enable=YES #允许匿名用户拥有重命名和删除的权限 设置目录拥有者匿名用户登录的目录默认为 /var/ftp ，但不可以直接修改匿名用户根目录 /var/ftp 所有者为 ftp ，否则将导致匿名用户不可以登录服务器。可以在匿名用户的根目录下新建子目录，来供匿名用户上传文件。例如 /var/ftp/pub 目录。 1chown ftp /var/ftp/pub //修改该目录的所有者为ftp 当修改 /var/ftp/pub 目录所有者为 ftp 后，匿名用户即可在此目录下上传文件。 启动服务1systemctl start vsftpd //启动vsftpd服务 如果在执行该命令后，没有任何提示信息，表示启动成功，可以通过 systemctl status vsftpd 命令来查看服务当前状态。 如果在执行该命令后，出现如下图所示信息，则表示服务没有启动成功，检查配置文件 /etc/vsftpd/vsftpd.conf 是否有错。 验证结果使用命令 ifconfig 可以查看服务器的IP地址 在客户端中打开windows资源管理器，地址栏中输入 ftp://服务器IP ，验证是否可以匿名登录，并下载上传文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python面向对象]]></title>
      <url>%2F2017%2F02%2F17%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[定义类12345678910class ClassName: statement1 ... statementN# 新式类class OldStyle:# 老式类class NewStyle(object): 构造函数1def __init__(self, [...]): 析构函数1def __del__(self, [...]): 类的属性定义类里定义直接在类里定义，类似于静态属性，不同对象之间是共享的 12class Programer(object): sex = 'male' 构造函数里定义在构造函数里面定义，不同对象之间是不共享的 1234class Programer(object): def __init__(self, name, age): self.name = name self.age = age 访问控制Python里面不提供访问控制，完全依靠程序员的自觉，常用属性定义： 123456789101112class Programer(object): def __init__(self, name, age, weight): self.name = name # 公有属性 self._age = age # 私有属性 self.__weight = weight # 变相私有属性# 当属性名有两个下划线时，Python会改变属性名，需要加类名if __name__ == '__main__': programer = Programer('Albert', 25, 80) print(programer.name) # Albert print(programer._age) # 25 print(programer._Programer__weight) # 80 以上为编程约束，而非语法约束 类的方法定义和属性定义类似，包括访问控制 123456789101112131415161718class Programer(object): def __init__(self, name, age, weight): self.name = name self._age = age self.__weight = weight @classmethod def get_hobby(cls): return cls.hobby @property def get_weight(self): return self.__weightif __name__ == '__main__': programer = Programer('Albert', 25, 80) print(Programer.get_hobby()) # 类方法通过类名调用 print(programer.get_weight) # 通过类似属性的方法调用，不需要括号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA['Python之常用内置函数']]></title>
      <url>%2F2017%2F02%2F08%2FPython%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[列举常用的内置函数 abs() 取绝对值 max() 取最大值 min() 取最小值 len() 取长度 divmod(x, y) 取商和模，返回一个tuple (x//y, x%y) pow(x, y[, z]) 求幂,x的y次幂,z表示求余 round() 四舍五入 callable() 测试函数是否可以被调用 isinstance() 判断类型是否为指定类型 cmp(x, y) 比较x和y的大小，如果 x&gt;y 返回 1 ，如果 x&lt;y 返回 -1，如果 x==y 返回 0 range() xrange() type() 查看对象类型 int() 转换成整型 long() 转换成长整型 float() 转换成浮点型 complex() str() list() tuple() hex() oct() chr() 将ASCII码转换成字符 ord() 将字符转换成ASCII码 123456789101112131415161718192021L = [1,2,3,4,5,6,7]print max(L) # 7print min(L) # 1print len(L) # 7print divmod(7, 3) # (2, 1)print pow(2,3,3) # 2 ^ 3 % 3 -&gt; 2f1 = 1print callable(f) # Falsedef f2(): passprint callable(f2) # Trueprint callable(max) # Trueprint isinstance(L, list) # Trueprint range(10) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print xrange(10) # xrange(10)print ord('A') # 65print chr(65) # A string函数 str.capitalize() 首字母大写 str.replace() 返回替换的字符串 str.split() 切割 1print 'abc'.capitalize() # Abc 序列处理函数 len() max() min() filter() zip() map() reduce()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA['Python之switch实现']]></title>
      <url>%2F2017%2F02%2F08%2FPython%E4%B9%8Bswitch%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[通过字典调用函数 {1:case1, 2:case2}.get(x,lambda arg, *key:)() 例如要实现一个加减乘除的计算器 12345678910111213141516171819from __future__ import divisiondef add(x, y): return x + ydef subtract(x, y): return x - ydef multiply(x, y): return x * ydef divide(x, y): return x / yresult = &#123; '+': add, '-': subtract, '*': multiply, '/': divide&#125;def f(x, op, y): print result.get(op)(x, y)f(4, '+', 9) # 13]]></content>
    </entry>

    
    <entry>
      <title><![CDATA['Python之lambda表达式']]></title>
      <url>%2F2017%2F02%2F08%2FPython%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[语法lambda语句中，冒号前是参数，可以有多个，用逗号隔开，冒号右边是返回值。 lambda语句构建的其实是一个函数对象 使用Python写一些执行脚本时，使用lambda可以省去定义函数的过程，让代码更加精简 对于一些抽象的，不会别的地方再复用的函数，有时候给函数起个名字也是个难题，使用lambda不需要考虑命名的问题 使用lambda在某些时候让代码更容易理解 12g = lambda x, y: x * yprint g(2, 3) # 6 类似于 12def f(x, y): return x * y 实例reduce()reduce() 函数会遍历整个list，然后将元素两两执行 123def f(x, y): return x * yprint reduce(f, [1,2,3,4,5]) # 120 上面的例子中，表示将 [1,2,3,4,5] 这个列表依次取出其中元素，然后两两代入 f() 函数中执行，如：执行 f(1, 2)，然后将结果作为 x 代入，和 3 执行 f(f(1, 2), 3) ，直到list遍历完成 这时函数 f(x, y) 就可以使用 lambda 表达式 求阶乘例如求阶乘 1print reduce(lambda x, y: x * y, range(1, 5)) # 4! = 24]]></content>
    </entry>

    
    <entry>
      <title><![CDATA['Python运算符']]></title>
      <url>%2F2017%2F02%2F08%2FPython%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[算术运算符 ‘+’加法：x + y ‘-‘减法：x - y ‘*‘乘法：x * y ‘/‘实数除法：3/2 -&gt; 1, 3.0/2 -&gt; 1.5 ‘//‘整数除法：5.6/2 -&gt; 2.8, 5.6//2 -&gt; 2.0 ‘%’求余数：除法求余运算，17 % 6 -&gt; 5 ‘**‘求幂运算：2 ** 3 -&gt; 8 关系运算符返回 True 或 False ‘&lt;’：小于 ‘&gt;’：大于 ‘&lt;=’：小于等于 ‘&gt;=’：大于等于 ‘!=’：不等于 ‘==’：完全等于 逻辑运算符与或非 对应 and , or , not，返回 True 或 False 运算符优先级从上到下优先级越来越高 Lambda 逻辑运算：or 逻辑运算：and 逻辑运算：not 成员测试：in, not in 同一性测试：is, is not 比较：&lt;, &lt;=, &gt;, &gt;=, !=, == 按位或：| 按位异或：^ 按位与：&amp; 移位：&lt;&lt;, &gt;&gt; 加法与减法：+, - 乘法、除法与取余：*, /, % 正负号：+x, -x 按位翻转：~x 指数：**]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python基础语法学习笔记]]></title>
      <url>%2F2017%2F02%2F05%2FPython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Python基础语法学习笔记，Python版本：2.7 看图快速入门 print语句不论学习什么编程语言，都是从 Hello,World! 开始，Python中的print使用方法： 123456# Python中的注释为井号开头print 'Hello,World!'# 字符串连接使用逗号print 'Hello ','World!' #输出结果为 "Hello World!"# 可以打印计算结果print '1 + 2 = ',1+2 #输出结果为 "1 + 2 = 3" 基本数据类型整数、浮点数和Java类似，整数没有小数点，浮点数带小数点，十六进制前面加 0x 字符串引号处理 使用单引号或者双引号括起来的文本，如果字符串内容包含引号，可以使用类似JS的方法，字符串包含单引号时使用双引号，字符串包含双引号时使用单引号。例： 12print "I'm OK" # I'm OKprint 'Learn "Python"' # Learn "Python" 转义处理 如果字符串内容既包含单引号又包含双引号时，可以使用转义字符 \ 1print 'Bob said \"I\'m OK\".' # Bob said "I'm OK". 常用转义字符： \n 表示换行 \t 表示一个制表符 \\ 表示一个\字符本身 如果一个字符串包含很多的转义字符,对每个转义字符进行转义就很麻烦，这时可以在字符串前面加一个前缀 r ,表示这是一个 raw 字符串,里面的字符就不需要转义了。例如：1print r'\(~_~)/ \(~_~)/' # \(~_~)/ \(~_~)/ 但是这种方法不能表示多行字符串和包含引号的字符串。 多行处理如果要表示多行字符串，可以用 &#39;&#39;&#39;...&#39;&#39;&#39; 表示: 12345678910print '''Line 1Line 2Line 3'''# Line 1# Line 2# Line 3# ------# 这个表示方法与下面表示方法完全一样# ------print 'Line 1\nLine 2\nLine 3' 还可以在多行字符串前面添加 r ,把这个多行字符串也变成一个 raw字符串： 123456print r'''Python is created by "Guido".It is free and easy to learn.Let's start learn Python in imooc!'''# Python is created by "Guido".# It is free and easy to learn.# Let's start learn Python in imooc! Unicode表示字符串使用 u&#39;...&#39; 表示 1print u'这里的汉字只用Unicode表示' 在使用Unicode表示时同样可以使用 转义字符 , 多行 , raw+多行 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 布尔值只有 True 和 False (注意大小写) 与或非与或非运算使用 and ， or ， not，例： 1print True and False # False 布尔类型还可以与其他数据类型做 and、or和not运算： 12a = Trueprint a and 'x' or 'y' # x 结果不是布尔类型，而是字符串 ‘x’ ，这是因为Python把 0 ， 空字符串&#39;&#39; ， None 看成 False ， 其他数值 和 非空字符串 都看成 True 短路计算 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 空值在Python中空值使用 None 表示，类似于Java中的Null 变量命名Python中的变量命名必须为 大小写英文字母、数字、下划线，且不能以数字开头 定义直接使用，不需要声明 1a = 1 在Python中可以把任意数据类型赋值给变量，类似与JS中的变量 12a = 1 # a为整数a = 'xyz' # a为字符串 内存中的表示当我们写 a = &#39;ABC&#39; 时，Python解释器干了两件事情： 在内存中创建了一个 &#39;ABC&#39; 的字符串； 在内存中创建了一个名为 a 的变量，并把它指向 &#39;ABC&#39; 。 1234a = 'ABC'b = aa = 'XYZ'print b # ABC 执行 a = &#39;ABC&#39; ，解释器创建了字符串 &#39;ABC&#39; 和变量 a ，并把 a 指向 &#39;ABC&#39; 执行 b = a ，解释器创建了变量 b ，并把 b 指向 a 指向的字符串 &#39;ABC&#39; 执行 a = &#39;XYZ&#39; ，解释器 创建了 字符串 &#39;XYZ&#39; ，并把 a 的指向改为 &#39;XYZ&#39; ，但 b 并没有更改 List类型定义和访问方式list是一种有序的集合，可以随时添加删除其中元素，表示方式： 1234L = ['Michael','Bob','Tracy',True,10]# 类似数组，按照索引访问，从0开始正序访问，负数表示倒序访问，从-1开始print L[0] # Michaelprint L[-1] # 10 append追加使用append()方法将新加入的元素追加到列表末尾 123L = ['Michael','Bob','Tracy',True,10]L.append('Paul')print L # ['Michael','Bob','Tracy',True,10,'Paul'] insert插入使用insert()方法将元素添加到指定位置，该位置原先的元素以及该位置之后的元素都向后移动一位 123L = ['Michael','Bob','Tracy',True,10]L.insert(1, 'Paul')print L # ['Michael','Paul','Bob','Tracy',True,10] pop删除使用pop()方法将指定位置元素删除 12345L = ['Michael','Paul','Bob','Tracy',True,10]L.pop(0) # 参数表示索引print L # ['Paul', 'Bob', 'Tracy', True, 10]L.pop() # 不填写参数删除最后一个元素print L # ['Paul', 'Bob', 'Tracy', True] 修改元素类似于数组的使用方法，通过变量名和索引直接赋值修改 12345L = ['Michael','Paul','Bob','Tracy',True,10]L[1] = 'Lisa'print L # ['Michael', 'Lisa', 'Bob', 'Tracy', True, 10]L[-1] = 20print L # ['Michael', 'Lisa', 'Bob', 'Tracy', True, 20] Tuple类型tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。 定义和访问方式123T = ('Michael','Paul','Bob','Tracy',True,10)print T[0] # Michaelprint T[-1] # 10 访问方式和list一样，但是不能对元素赋值，也没有append()方法，insert()方法和pop()方法 创建单元素tuple创建0个元素的tuple 12T = ()print T # () 创建1个元素的tuple 1234T = (1)print T # 1T = (1,)print T # (1,) 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号 , 创建“可变的”tuple12345T = ('a', 'b', ['A', 'B'])L = T[2]L[0] = 'x'L[1] = 'y'print T # ('a', 'b', ['x', 'y']) 当tuple中的元素包含list时，这是的tuple元素并没有改变，指向的还是那个list，改变的是list的元素，tuple只是指向不能改变 if条件判断语法123age = 20if age &gt;= 18: print 'adult' if后面跟判断的条件并加个冒号，通过缩进构成一个语句块，所以缩进时不能使用 tab ，要使用空格,否则很容易造成因为缩进引起的错误 if-elseif和else后面都有冒号 12345age = 20if age &gt;= 18: print 'adult'else: print 'teenager' if-elif-else当有多个条件判断时使用，同样注意冒号 123456789score = 85if score &gt;= 90: print 'excellent'elif score &gt;= 80: print 'good'elif score &gt;= 60: print 'passed'else: print 'failed' 循环for类似foreach语句，将每个元素迭代出来，适用于list、tuple、dict 123L = ['Adam', 'Lisa', 'Bart']for name in L: print name while循环根据表达式判断循环是否结束， 注意冒号 1234x = 0while x &lt; 10: print x x = x + 1 break、continue使用方法和Java中的类似 dict集合定义使用 key-value 的表示方法 12345d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125; 访问dict123456d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125;print d['Adam'] # 95 当key不存在时，使用这种方法访问会报错，有两种解决办法： 在访问前加一个if判断key是否存在 12if 'Adam' in d print d['Adam'] 使用dict提供的 get() 方法，当key不存在的时候返回None 1print d.get('Adam') 特点 查找速度快，无论dict有10个元素还是10万个元素查找速度都一样，而list会根据元素数量的增加查找速度降低 占用内存大，list正好相反，占用内存小 key不能重复 dict存储的 key-value 是没有顺序的，这和list不一样 不能使用可变的元素作为key，例如整型、字符串、浮点数都是不可变的，可以作为key，而list是可变的，不能作为key 更新dict使用类似数组的方法进行更新 1d['Paul'] = 72 当 &#39;Paul&#39; 存在于这个dict中时，则替换其value。不存在于这个dict中时，则新增这个key-value 遍历dict使用for语句循环遍历 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125;for key in d: print key # 输出所有key print d[key] # 输出所有value set一系列不能重复，无序的元素 定义创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素 1s = set(['A','B','C']) 访问set访问 set中的某个元素实际上就是判断一个元素是否在set中 123s = set(['A','B','C'])print 'A' in s # Trueprint 'a' in s # False 更新set add()方法添加元素，如果添加的元素已经存在，不会报错 remove()方法删除元素，如果删除的元素不存在，则会报错，所以删除前先判断 函数定义定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。 如果没有 return 语句，则函数执行完毕返回为 None ， return None 也可以简写为 return 1234567# 定义一个函数square_of_sum()，接收一个list，返回list中每个元素平方的和def square_of_sum(L): sum = 0 for x in L: sum += x * x return sumprint square_of_sum([1,2,3,4,5]) # 55 返回多个值比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标 1234567891011import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, nyx, y = move(0, 0, 60, math.pi / 6)print x, y # 51.9615242271 -30.0# 但其实这只是一种假象，Python函数返回的仍然是单一值r = move(100, 100, 60, math.pi / 6)print r # (151.96152422706632, 70.0)# 返回值为一个tuple 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 函数递归使用递归函数需要注意防止栈溢出 阶乘1234def fact(n): if n == 1: return 1 return fact(n - 1) * n 汉诺塔1234567def move(n, a, b, c): if n == 1: print a, '--&gt;', c else: move(n - 1, a, c, b) move(1, a, b, c) move(n - 1, b, a, c) 默认参数定义函数的时候，可以带有默认参数，类似与C++中的默认参数，默认参数从后向前定义 123456789# 计算x的N次方，默认为2次def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5) # 25power(5, 3) # 125 可变参数以元组方式在可变参数前面加上 * 号，可以传入0个、1个或者多个参数 1234567891011# 求N个参数的平均值def average(*args): sum = 0.0 if len(args) == 0: return sum for x in args: sum = sum + x return sum / len(args)print average(1,2,3,4,5,5,5) # 3.57142857143print average() # 0.0 以字典方式在可变参数前面加上 ** 号 1234def f(**x): print x f(x=1,y=2) # &#123;'y': 2, 'x': 1&#125; 切片对list和tuple切片 两个参数 L[0:3] ，用冒号隔开，表示从索引为 0（包含） 开始，到索引为 3（不包含） 结束的list 从0开始，可以省略0， L[:3] 没有参数，只写冒号，表示从头到尾 三个参数，前两个表示范围，第三个表示步长 换成 tuple 写法完全相同，只不过结果变为 tuple 1234567891011L = ['A', 'B', 'C', 'D', 'E', 'F']print L[0:3] # ['A', 'B', 'C']print L[:3] # ['A', 'B', 'C']print L[1:4] # ['B', 'C', 'D']print L[:] # ['A', 'B', 'C', 'D', 'E', 'F']print L[1:4:2] # ['B', 'D']print L[:3:2] # ['A', 'C']print L[::2] # ['A', 'C', 'E']t = ('a', 'b', 'c', 'd', 'e', 'f')print t[::2] # ('a', 'c', 'e') 倒序切片表示方法为负数，倒数第一个索引是 -1 12L = ['A', 'B', 'C', 'D', 'E', 'F']print L[-4:-2] # ['C', 'D'] 字符串切片字符串 &#39;xxx&#39; 和 Unicode字符串 u&#39;xxx&#39; 也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串 123456print 'ABCDEFG'[:3] # ABC# 首字母大写def firstCharUpper(s): return s[0].upper() + s[1:]print firstCharUpper('hello') # Hello 迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。 普通迭代Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。 注意 : 集合是指包含一组元素的数据结构，我们已经介绍的包括： 有序集合：list，tuple，str和unicode； 无序集合：set 无序集合并且具有 key-value 对：dict 使用for循环输出1~100中7的倍数 方法1：123for x in range(1, 101): if x % 7 == 0: print x 方法2：12for x in range(7, 101, 7): print x 方法3：12for x in range(7, 101)[::7]: print x 索引迭代对于有序集合，元素确实是有索引的，如果要在for循环中拿到索引，使用 enumerate() 函数 123456789L = ['A', 'B', 'C', 'D', 'E', 'F']for index, name in enumerate(L): print index, '-', name# 0 - A# 1 - B# 2 - C# 3 - D# 4 - E# 5 - F 实际上， enumerate() 函数把 [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] 变成了类似： [(0, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;C&#39;), (3, &#39;D&#39;), (4, &#39;E&#39;), (5, &#39;F&#39;)] ，因此迭代的每一个元素是一个 tuple 12345L = ['A', 'B', 'C', 'D', 'E', 'F']for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, '-', name 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的 tuple ，再迭代，就同时获得了索引和元素本身。 迭代dict的value对于dict对象，用 for 循环直接迭代，每次拿到的是 key，如果要拿到 value，有两种方法： values()可以使用 values() 方法，这个方法把dict转换成一个包含所有 value 的 list 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.values() # [85, 95, 59]for x in d.values(): print x # 85 # 95 # 59 itervalues()使用 itervalues() 方法，迭代效果完全一样 12345678d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.itervalues() # &lt;dictionary-valueiterator object at 0x0000000002C1B368&gt;for x in d.itervalues(): print x # 85 # 95 # 59 两种方法的区别 values() 方法实际上把一个 dict 转换成了包含 value 的 list 。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value ，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的 内存 。 打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict 等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种 抽象 的数据操作，它不对迭代对象内部的数据有任何要求。 同时迭代dict的key和valueitems()12d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print d.items() # [('Lisa', 85), ('Adam', 95), ('Bart', 59)] 可以看到， items() 方法把 dict 对象转换成了包含 tuple 的 list ，我们对这个 list 进行迭代，可以同时获得 key 和 value ： 123456d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;for key, value in d.items(): print key, ':', value # Lisa : 85 # Adam : 95 # Bart : 59 iteritems()iteritems() 不把 dict 转换成 list ，而是在迭代过程中不断给出 tuple ，所以， iteritems() 不占用额外的内存。 使用方法和 items() 类似 列表生成式生成列表1print range(1, 11) # [1,2,3,4,5,6,7,8,9,10] 如果要生成 [1x1, 2x2, 3x3, …, 10x10] 1234L = []for x in range(1, 11): L.append(x * x)print L # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种方法太繁琐，列表生成式可以用一行语句代替循环生成上面的list 1print [x * x for x in range(1, 11)] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 复杂表达式使用 for 循环的迭代不仅可以迭代普通的 list ，还可以迭代 dict ，用复杂的列表生成式生成一个HTML表格 1234567891011121314d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table border="1"&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;/tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;'# &lt;table border="1"&gt;# &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;/tr&gt;# &lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;# &lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;# &lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;# &lt;/table&gt; 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 1print [x * x for x in range(1, 11)] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，在不改动 range() 的情况下，可以加上 if 来筛选 1print [x * x for x in range(1, 11) if x % 2 == 0] # [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 多层表达式for 循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 12L = [m + n for m in 'ABC' for n in '123']print L # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻译成循环代码就像这样 12345L = []for m in 'ABC': for n in '123': L.append(m + n)print L # ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 1print [100*x + 10*y + z for x in range(1,10) for y in range(1,10) for z in range(1,10) if x == z]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现鼠标拖动控件效果]]></title>
      <url>%2F2017%2F01%2F13%2F%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%8B%96%E5%8A%A8%E6%8E%A7%E4%BB%B6%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[在程序运行过程中，通过鼠标拖动实现控件的移动效果。 原理通过设置被拖动控件的 MouseUp ， MouseDown 和 MouseMove 事件来实现。 MouseDown 事件用来检测鼠标左键按下事件，并且记录当前控件的位置坐标 MouseUp 事件用来标记控件移动效果结束 MouseMove 事件根据鼠标当前位置和开始位置计算控件的位置坐标，并实时设置控件的位置坐标 准备 打开Visual Studio 2013 新建一个 Windows窗体应用程序 项目 在窗体 Form1 中创建一个控件，例如 Button 控件,命名为 button1 实现添加全局变量添加两个全局变量， _clickPoint 用来记录单击时的位置， _isMove 用来判断是否要移动 12345public partial class Form1 : Form&#123; private Point _clickPoint; private bool _isMove = false;&#125; 添加 MouseDown 事件1234567891011private void button1_MouseDown(object sender, MouseEventArgs e)&#123; // 判断是否按下鼠标左键 if (e.Button != System.Windows.Forms.MouseButtons.Left) &#123; return; &#125; _isMove = true; // 记录当前位置 _clickPoint = e.Location;&#125; 添加 MouseMove 事件12345678private void button1_MouseMove(object sender, MouseEventArgs e)&#123; if (_isMove) &#123; Point newPoint = ((Control)sender).Parent.PointToClient(Cursor.Position); ((Control)sender).Location = new Point(newPoint.X - _clickPoint.X, newPoint.Y - _clickPoint.Y); &#125;&#125; 添加 MouseUp 事件1234private void button1_MouseUp(object sender, MouseEventArgs e)&#123; _isMove = false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[判断字符串是否为HTML标签]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BAHTML%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[有个同学问我，给定一个字符串，然后怎样判断该字符串是否为HTML标签？我自己想了一下，第一反应觉得处理字符串使用正则表达式判断可能比较好。然后经过简单分析，写了一段简单的代码 利用正则表达式方法一这里用的表达式比较简单，只能判断字符串是以 “&lt;” 开始，以 “&gt;” 结束 表达式^&lt;.+&gt;$ 图示 代码123String regex = "^&lt;.+&gt;$";String str = "&lt;a&gt;";System.out.println(str.matches(regex)); 由于这种方法判断过于简单，所以将表达式改进一下。 方法二改进后的正则表达式，判断更加准确 双标签 以 “&lt;” 和 “&gt;” 扩住内容为开始标签和结束标签 “&lt;” 和 “&gt;” 中间内容不能为空 单标签 以 “&lt;” 为开始 中间标签名不能为空 以 “/&gt;” 或者 “&gt;” 结尾 表达式(^&lt;[^&gt;]+&gt;.*&lt;[^&gt;]+&gt;$|^&lt;[^/&gt;]+(\/&gt;|&gt;)$) 图示 代码123String regex = "(^&lt;[^&gt;]+&gt;.*&lt;[^&gt;]+&gt;$|^&lt;[^/&gt;]+(\\/&gt;|&gt;)$)";String str = "&lt;br/&gt;";System.out.println(str.matches(regex)); 这种方法稍稍有点改进，但是还是感觉不能满足要求。最大的缺点就是对于双标签，开始标签和结束标签名可以不同而这在html规范中是不允许的，网上查了一下，没找到正则表达式中怎么表示变量所以想到了利用栈进行前后标签匹配，类似于处理括号配对问题于是有了不利用正则表达式的方法 利用栈思路 对字符串进行逐个字符分析 增加符合标签规范的判断条件 将开始标签名入栈 将结束标签名按字符逆序与栈内字符逐个比较 流程图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*** 测试字符串是否为HTML标签* @param str* @return*/public boolean testHtml(String str)&#123; char[] arr = str.toCharArray(); boolean isSpace = false; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); stack.clear(); //小于最小标签长度 if (arr.length &lt; 3)&#123; return false; &#125; //不是以 '&lt;' 开头和 '&gt;' 结尾 if (arr[0] != '&lt;' || arr[arr.length - 1] != '&gt;')&#123; return false; &#125; //标签内部不是以字母开头 if (!Character.isLetter(arr[1]))&#123; return false; &#125; //最后是以 "/&gt;" 结尾 if (arr[arr.length - 2] == '/')&#123; //单标签 return true; &#125; else &#123; //双标签 //顺序遍历 for (int i = 2; i &lt; arr.length; i++)&#123; //是否为空格 if (arr[i] == ' ')&#123; isSpace = true; &#125; else &#123; //是否为'&gt;' if (arr[i] == '&gt;')&#123; //'&gt;'入栈 stack.push(arr[i]); //是否是最后一个字符 if (i == arr.length - 1)&#123; return true; &#125; else &#123; break; &#125; &#125; else &#123; //是否为属性 if (isSpace)&#123; continue; &#125; else &#123; //标签名入栈 stack.push(arr[i]); &#125; &#125; &#125; &#125; //逆序遍历 for (int i = arr.length - 1; i &gt;= 0; i--)&#123; if (stack.isEmpty())&#123; return true; &#125; else &#123; Character c = stack.pop(); //与栈内字符匹配 if (arr[i] != c)&#123; if (arr[i] != '/')&#123; return false; &#125; &#125; &#125; &#125; &#125; System.out.println("fuck"); return false;&#125; 这种方法比较麻烦，但是相对于前几种方法来说判断比较准确 可以检测单标签、双标签。 可以判断开始标签和结束标签是否标签名相同 但是不能判断标签名是否为html规范标签名 不能判断标签属性是否符合规范]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas绘制基础]]></title>
      <url>%2F2016%2F12%2F07%2Fcanvas%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[创建canvasHtml部分 添加canvas标签，指定id属性便于JS获取到这个元素 在canvas标签中添加文字，当浏览器不支持canvas标签时，便会显示该文字，若浏览器支持canvas，则隐藏文字内容。 设置canvas的样式，便于看到canvas区域 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;canvas绘制基础&lt;/title&gt; &lt;style&gt; #canvas &#123; display: block; margin: 10px auto; border: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt; 当前浏览器不支持canvas，请更换浏览器后再试 &lt;/canvas&gt; &lt;script src="canvas.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js部分 根据id获取canvas元素 通过 canvas.width 和 canvas.height 设置canvas画布的大小 通过 canvas.getContext(&#39;2d&#39;) 方法获取context 对context操作，绘制图形 1234567var canvas = document.getElementById('canvas');canvas.width = 600;canvas.height = 600;var context = canvas.getContext('2d');//进行绘制 绘制图形绘制直线 通过 context.beginPath() 方法来开始一条路径，或重置当前路径 context.moveTo(x, y) 方法来把路径移动到 (x, y) ，不创建线条 context.lineTo(x, y) 方法来添加一个新的点，然后在画布中创建从该点到最后指定点的线条 使用 context.lineWidth 设置或返回当前线条的宽度 使用 context.strokeStyle 设置或返回用于笔触的颜色、渐变或模式 最后通过 context.stroke() 方法绘制已定义的路径 如果要创建多条线条，通过 context.lineTo(x, y) 方法来顺序添加点 12345678context.beginPath();context.moveTo(100, 100);context.lineTo(400, 400);context.lineWidth = 5;context.strokeStyle = '#f00';context.stroke(); 填充 绘制路径，与绘制直线相同 通过 context.closePath() 创建从当前点回到起始点的路径，使路径闭合 通过 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 通过 context.fill() 方法填充 12345678910context.beginPath();context.moveTo(100, 100);context.lineTo(400, 400);context.lineTo(100, 400);context.closePath();context.fillStyle = '#0f0';context.fill(); 绘制弧线通过 context.arc()方法来绘制弧线 语法 context.arc(x, y, r, sAngle, eAngle, counterclockwise) 参数 描述 x 圆的中心的 x 坐标 y 圆的中心的 y 坐标 r 圆的半径 sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度） eAngle 结束角，以弧度计 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针 弧度三点钟位置是 0 度，然后按照顺时针方向，6点钟是 0.5*PI ，9点钟是 1*PI ，12点钟是 1.5*PI ，3点钟是 2*PI 不论 counterclockwise 参数设置为 true 还是 false ，弧度表示位置始终不变 12345context.beginPath();context.lineWidth = 5;context.strokeStyle = '#f00';context.arc(300, 300, 200, 0, 1.5*Math.PI);context.stroke(); 绘制实心圆将弧线进行填充即可 1234context.beginPath();context.fillStyle = '#00f';context.arc(300, 300, 200, 0, 1.5*Math.PI);context.fill();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate单表CRUD操作]]></title>
      <url>%2F2016%2F12%2F04%2FHibernate%E5%8D%95%E8%A1%A8CRUD%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[方法 save update delete get/load(查询单个记录) get与load的区别 在不考虑缓存的情况下，get方法会在调用之后立即向数据库发出sql语句，返回持久化对象。load方法会在调用后返回一个代理对象。该代理对象只保存了实体对象的id，直到使用对象的非主键属性时才会发出sql语句。 查询数据库中不存在的数据时，get方法返回nullload方法抛出异常org.hibernate.ObjectNotFoundException]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate中session的使用]]></title>
      <url>%2F2016%2F12%2F04%2FHibernate%E4%B8%ADsession%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[获取session的方式 sessionFactory.openSession sessionFactory.getCurrentSession 如果使用getCurrentSession需要在hibernate.cfg.xml文件中进行配置：如果是本地事务（jdbc事物）&lt;propertyname=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;如果是全局事务(jta事务)&lt;propertyname=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt; 两种方式的区别 getCurrentSession在事务提交或者回滚之后会自动关闭，而openSession需要你手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出。 openSession每次创建新的session对象，getCurrentSession使用现有的session对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate.cfg.xml常用配置]]></title>
      <url>%2F2016%2F12%2F04%2FHibernate-cfg-xml%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[属性名字 含义 hibernate.show_sql 是否把Hibernate运行时的SQL语句输出到控制台，编码阶段便于测试。 hibernate.format_sql 输出到控制台的SQL语句是否进行排版，便于阅读。建议设置为true hbm2ddl.auto 可以帮助由java代码生成数据库脚本，进而生成具体的表结构。create&#124;update&#124;create-drop&#124;validate hibernate.default_schema 默认的数据库 hibernate.dialect 配置Hibernate数据库方言，Hibernate可针对特殊的数据库进行优化 hibernate可以省略,比如hibernate.dialect可以写成dialect]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate基本类型]]></title>
      <url>%2F2016%2F12%2F04%2FHibernate%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[基本数据类型 Hibernate映射类型 Java类型 标准SQL类型 大小 integer/int java.lang.Integer/int INTEGER 4字节 long java.lang.Long/long BIGINT 8字节 short java.lang.Short/short SMALLINT 2字节 byte java.lang.Byte/byte TINYINT 1字节 float java.lang.Float/float FLOAT 4字节 double java.lang.Double/double DOUBLE 8字节 big_decimal java.math.BigDecimal NUMERIC character java.lang.Character/java.lang.String/char CHAR(1) 定长字符 string java.lang.String VARCHAR 变长字符 boolean/yes_no/true_false java.lang.Boolean/Boolean BIT 布尔类型 date java.util.Date/java.sql.Date DATE 日期 timestamp java.util.Date/java.util.Timestamp TIMESTAMP 日期 calendar java.util.Calendar TIMESTAMP 日期 时间 Hibernate映射类型 Java类型 标准SQL类型 描述 date java.util.Date或java.sql.Date DATE 代表日期：yyyy-MM-dd time javautilDate或java.sql.Time TIME 代表时间：hh:mm:ss timestamp java.util.Date或java.sql.Timestamp TIMESTAMP 代表时间和日期：yyyyMMddhhmmss calendar java.util.Calendar TIMESTAMP 同上 calendar_date java.util.Calendar DATE 代表日期：yyyy-MM-dd 对象类型 映射类型 Java类型 标准SQL类型 MYSQL类型 Oracle类型 binary byte[] VARCHAR(或BLOB) BLOB BLOB text java.lang.String CLOB TEXT CLOB clob java.sql.Clob CLOB TEXT CLOB blob java.sql.Blob BLOB BLOB BLOB Mysql不支持标准SQL的CLOB类型，在Mysql中，用TEXT,MEDIUMTEXT及LONGTEXT类型来表示长度超过255的长文本数据。 组件属性实体类中的某个属性属于用户自定义的类的对象 12345&lt;component name="address" class="Address"&gt; &lt;property name="postcode" column="POSTCODE"&gt;&lt;/property&gt; &lt;property name="phone" column="PHONE"&gt;&lt;/property&gt; &lt;property name="address" column="ADDRESS"&gt;&lt;/property&gt;&lt;/component&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hbm配置文件常用设置]]></title>
      <url>%2F2016%2F12%2F04%2Fhbm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[配置 12345678910111213141516171819202122&lt;hibernate-mapping schema="schemaName" catalog="catalogName" default-cascade="cascade_style" //级联风格 default-access="field|property|ClassName" //访问策略 default-lazy="true|false" //加载策略 package="packagename"/&gt;&lt;class name="ClassName" table="tableName" batch-size="N" where="condition" entity-name="EntityName"/&gt;&lt;id name="propertyName" type="typename" column="column_name" length="length"&gt; &lt;generator class="generatorClass"/&gt;&lt;/id&gt; 主键生成策略 标识符生成器 描述 increment 适用于代理主键。由Hibernate自动以递增方式生成。 identity 适用于代理主键。由低层数据库生成标识符。 sequence 适用于代理主键。Hibernate根据底层数据库的序列生成标识符，这要求底层数据库支持序列。 hilo 适用于代理主键。Hibernate分局high/low算法生成标识符。 seqhilo 适用于代理主键。使用一个高/低位算法来高效的生成long，short或者int类型的标识符 native 适用于代理主键。根据底层数据库对自动生成标识符的方式，自动选择identity、sequence或hilo uuid.hex 适用于代理主键。Hibernate采用128位的UUID算法生成标识符 uuid.string 适用于代理主键。UUID被编码成一个16字符长的字符串 assigned 适用于自然主键。由Java应用程序负责生成标识符 foreign 适用于代理主键。使用另外一个相关联的对象的标识符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate开发基本步骤]]></title>
      <url>%2F2016%2F12%2F04%2FHibernate%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[步骤 编写配置文档hibernate.cfg.xml 编写实体类（符合JavaBean规范） 生成对应实体类的映射文件并添加到配置文档中 调用Hibernate API进行测试 代码123456789101112131415161718//创建配置对象Configuration config = new Configuration().configure();//创建服务注册对象StandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();//创建会话工厂sessionFactory = config.buildSessionFactory(standardRegistry);//会话对象session = sessionFactory.openSession();//开启事务transaction = session.beginTransaction();Student stu = new Student(1, "张三", "男", new Date(), "中国");session.save(stu);//提交事务transaction.commit();//关闭会话session.close();//关闭会话工厂sessionFactory.close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSTL标签和函数的使用]]></title>
      <url>%2F2016%2F12%2F04%2FJSTL%E6%A0%87%E7%AD%BE%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[环境配置 将jstl.jar和standard.jar两个包导入到项目中 使用标签添加&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 使用函数添加&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt; 标签的使用赋值和输出标签12345&lt;c:out value="要输出的内容"&gt;&lt;/c:out&gt;&lt;!-- 给javabean赋值--&gt;&lt;jsp:useBean id="stu" class="jstlDemo.Student"&gt;&lt;/jsp:useBean&gt;&lt;c:set target="$&#123;stu&#125;" property="name" value="张三" &gt;&lt;/c:set&gt;&lt;c:out value="$&#123;stu.name&#125;"&gt;&lt;/c:out&gt; catch标签12345&lt;c:catch var="error"&gt; &lt;%-- 由于asdf变量不存在，输出错误信息--%&gt; &lt;c:set target="$&#123;asdf&#125;" property="asdf"&gt;&lt;/c:set&gt;&lt;/c:catch&gt; &lt;c:out value="$&#123;error&#125;"&gt;&lt;/c:out&gt; 条件判断标签if标签1234567891011&lt;form action="index.jsp" method="post"&gt; &lt;input type="text" name="score"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;c:if test="$&#123;param.score&gt;=90&#125;"&gt; &lt;c:out value="优秀"&gt;&lt;/c:out&gt;&lt;/c:if&gt;&lt;c:if test="$&#123;param.score&gt;=80 &amp;&amp; param.score&lt;90&#125;"&gt; &lt;c:out value="良好"&gt;&lt;/c:out&gt;&lt;/c:if&gt; choose、when、otherwise标签类似于switch 1234567891011121314151617181920&lt;c:choose&gt; &lt;c:when test="$&#123;param.score&gt;=90 &amp;&amp; param.score&lt;=100&#125;"&gt; &lt;c:out value="优秀"&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:when test="$&#123;param.score&gt;=80 &amp;&amp; param.score&lt;90&#125;"&gt; &lt;c:out value="良好"&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:when test="$&#123;param.score&gt;=70 &amp;&amp; param.score&lt;80&#125;"&gt; &lt;c:out value="中等"&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:when test="$&#123;param.score&gt;=60 &amp;&amp; param.score&lt;70&#125;"&gt; &lt;c:out value="及格"&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:when test="$&#123;param.score&lt;60 &amp;&amp; param.score&gt;=0&#125;"&gt; &lt;c:out value="不及格"&gt;&lt;/c:out&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;c:out value="您的输入错误"&gt;&lt;/c:out&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签foreach标签属性： var 自己定义的变量名，必需 items 要遍历的集合，必需 begin 开始的位置，从0开始 end 结束的位置 step 步长 varStatus 自己定义的状态名，用来调用四个属性 index 当前var的索引 count 当前var的排名 first 当前var如果是第一个返回true,否则返回false last 当前var如果是最后一个返回true，否则返回true 12345678910111213141516171819202122&lt;% List&lt;String&gt; fruits = new ArrayList&lt;String&gt;(); fruits.add("apple"); fruits.add("orange"); fruits.add("pear"); fruits.add("watermelon"); fruits.add("banana"); fruits.add("grape"); request.setAttribute("fruits", fruits);%&gt;&lt;c:forEach var="fruit" items="$&#123;fruits&#125;" begin="0" end="4" step="2"&gt; &lt;c:out value="$&#123;fruit&#125;"&gt;&lt;/c:out&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;c:forEach var="fruit" items="$&#123;fruits&#125;" varStatus="fru" step="2"&gt; &lt;c:out value="$&#123;fruit&#125;"&gt;&lt;/c:out&gt;&lt;br&gt; &lt;c:out value="index:$&#123;fru.index&#125;"&gt;&lt;/c:out&gt;&lt;br&gt; &lt;c:out value="count:$&#123;fru.count&#125;"&gt;&lt;/c:out&gt;&lt;br&gt; &lt;c:out value="first:$&#123;fru.first&#125;"&gt;&lt;/c:out&gt;&lt;br&gt; &lt;c:out value="last:$&#123;fru.last&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;/c:forEach&gt; forTokens标签类似字符串处理中的split 12345678&lt;!-- 将items字符串按照delims给定的字符切割，返回到var给定的变量中 --&gt;&lt;c:forTokens items="abc,defghi,jklmn,opq,rst,uvwxyz" delims="," var="str"&gt; &lt;c:out value="$&#123;str&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;/c:forTokens&gt;&lt;!-- begin指定遍历开始位置(int型取值0开始) --&gt;&lt;!-- end指定遍历结束的位置(int型,默认集合中最后一个元素 --&gt;&lt;!-- step遍历的步长(大于0的整型) --&gt;&lt;!-- varStatus通过index、count、first、last几个状态值，描述begin和end子集中的元素的状态 --&gt; 其他标签import标签直接导入网络上的页面123&lt;c:catch var="error"&gt; &lt;c:import url="http://www.imooc.com"&gt;&lt;/c:import&gt;&lt;/c:catch&gt; 导入同项目中的页面1234&lt;c:catch var="error"&gt; &lt;c:import url="abc.txt" var="abc" scope="session" charEncoding="utf-8"&gt;&lt;/c:import&gt; &lt;c:out value="$&#123;sessionScope.abc &#125;"&gt;&lt;/c:out&gt;&lt;/c:catch&gt; 导入同服务器中其他项目中的页面123&lt;c:catch var="error07"&gt; &lt;c:import url="/index.jsp" context="/WebLoginDemo"&gt;&lt;/c:import&gt;&lt;/c:catch&gt; redirect标签1234&lt;c:redirect url="another.jsp"&gt; &lt;c:param name="username"&gt;张三&lt;/c:param&gt; &lt;c:param name="password"&gt;123&lt;/c:param&gt;&lt;/c:redirect&gt; url标签12&lt;c:url var="aa" value="http://localhost/abcde.jsp"&gt;&lt;/c:url&gt;&lt;a href="$&#123;aa&#125;"&gt;链接&lt;/a&gt; 函数的使用描述 函数 描述 fn:contains() 确定输入字符串是否包含指定字符串 fn:containsIgnoreCase() 确定输入字符串是否包含指定字符串（忽略大小写） fn:end() 确定输入的字符串是否由指定字符串结束 fn:escapeXml() 忽略用XML标记的字符 fn:indexOf() 返回指定字符串在输入字符串出现的位置 fn:length() 返回字符串的长度或集合中的项目数 fn:replace() 替换一个字符串与另一个字符串的所有匹配 fn:split() 分隔字符串后将子串存储在数组中 fn:startsWith() 确定输入的字符串是否由指定字符串开始 fn:substring() 返回字符串的子集 fn:toLowerCase() 将字符串转换为小写 fn:toUpperCase() 将字符串转换为大写 fn:trim() 去掉字符串开头和结尾的空格 使用12345&lt;c:out value="$&#123;fn:contains('Hello world!','hel')&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="$&#123;fn:containsIgnoreCase('Hello world!','hel')&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="$&#123;fn:startsWith('Hello world','Hello')&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="$&#123;fn:endsWith('Hello world','d')&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value="index值：$&#123;fn:indexOf('Hello world','llo')&#125;"&gt;&lt;/c:out&gt;&lt;br&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[注解]]></title>
      <url>%2F2016%2F12%2F04%2F%E6%B3%A8%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[JDK自带注解 @Override 重写 @Deprecated 过时 @SuppressWarnings 忽略过时 @SuppressWarnings(“deprecation”) 常见第三方注解Spring @Autowired @Service @Repository Mybatis @InsertProvider @UpdateProvider @Options 注解的分类按照运行机制 源码注解 编译时注解 运行时注解 按照来源分 来自JDK的注解 来自第三方的注解 我们自己定义的注解 元注解自定义注解语法 使用 @interface 关键字定义注解 成员以无参无异常方式声明 可以用 default 为成员指定一个默认值 成员类型是受限的，合法的类型包括原始类型及String,Class,Annotation,Enumeration 如果注解只有一个成员，则成员名必须取名为 value() ,在使用时可以忽略成员名和赋值号(=) 注解类可以没有成员，没有成员的注解类称为标识注解 代码123456789@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description&#123; String desc(); String author(); int age() default 18;&#125; 自定义注解的使用语法@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,...) 代码1234@Description(desc="I am eyeColor", author="XinJi boy", age=18)public String eyeColor()&#123; return "red";&#125; 注意由于自定义注解的作用域 @Target({ElementType.METHOD,ElementType.TYPE}) 只在方法、类、接口，所以可以在 eyeColor() 方法使用 元注解@Target 作用域 CONSTRUCTOR 构造方法声明 FIELD 字段声明 LOCAL_VARIABLE 局部变量声明 METHOD 方法声明 PACKAGE 包声明 PARAMETER 参数声明 TYPE 类，接口 @Retention 生命周期 SOURCE 只在源码显示，编译时会丢弃 CLASS 编译时会记录到class中，运行时忽略 RUNTIME 运行时存在，可以通过反射读取@Inherited 允许子类继承 @Documented 生成javadoc时会包含注解1234@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP九大内置对象]]></title>
      <url>%2F2016%2F12%2F04%2FJSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[九大内置对象 JSP对象 获得方式 out resp.getWriter request service方法中的req参数 response service方法中的resp参数 session req.getSession()函数 application getServletContext()函数 exception Throwable page this pageContext PageContext Config getServletConfig函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合]]></title>
      <url>%2F2016%2F12%2F04%2FJava%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[集合中的两个根接口: Collection Map Collection: List： 排列有序，可重复 ArrayList LinkedList Queue： 排列有序，可重复 LinkedList Set： 无序，不可重复 HashSet Map: HashMap Entry键值对]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java异常]]></title>
      <url>%2F2016%2F12%2F04%2FJava%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[异常分类 Throwable Error Exception Error:系统错误 虚拟机错误:VirtualMachineError 线程死锁:ThreadDeath Exception: RuntimeException(非检查异常) IOException、SQLException(检查异常) RuntimeException: NullPointerException(空指针异常) ArrayIndexOutOfBoundsException(数组下标越界异常) ClassCastException(类型转换异常) ArithmeticException(算术异常) Java中的异常抛出throws:声明将要抛出何种类型的异常（声明）1234public void 方法名(参数列表) throws 异常列表&#123; //调用会抛出异常的方法或者： throw new Exception();&#125; throw:将产生的异常抛出（动作） 自定义异常123class 自定义异常类 extends 异常类型&#123;&#125; 实际应用中的经验与总结 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个 catch(Exception) 来处理可能会被遗漏的异常 对于不确定的代码，也可以加上 try-catch ，处理潜在的异常 尽量去处理异常，切记只是简单的调用 printStackTrance() 去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加 finally 语句块去释放占用的资源]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket实现UDP通信]]></title>
      <url>%2F2016%2F12%2F04%2FSocket%E5%AE%9E%E7%8E%B0UDP%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[进行数据传输时，首先需要将要传输的数据定义成数据报（Datagram），在数据报中指明数据所要达到的Socket（主机地址和端口号），然后再将数据报发送出去。 相关操作类 DatagramPacket：表示数据报包 DatagramSocket：进行端到端通信的类 服务器端实现步骤 创建DatagramSocket，指定端口号 创建DatagramPacket 接收客户端发送的数据信息 读取数据 客户端实现步骤 定义发送信息 创建DatagramPacket，包含将要发送的信息 创建DatagramSocket4.发送数据 代码服务器端123456789101112131415161718192021222324252627282930313233343536try &#123; /* * 服务器端接收客户端发送的数据 */ //创建服务器端DatagramSocket，指定端口 DatagramSocket socket = new DatagramSocket(8800); //创建数据报，用于接收客户端发送的数据 byte[] data = new byte[1024];//创建字节数组，指定接收数据包的大小 DatagramPacket packet = new DatagramPacket(data, data.length); //接收客户端发送的数据 System.out.println("***服务器已启动，等待客户端发送数据***"); socket.receive(packet);//此方法在接收到数据报之前会一直阻塞 //读取数据 String info = new String(data, 0, packet.getLength()); System.out.println("我是服务器，客户端说：" + info); /* * 向客户端响应数据 */ //定义客户端的地址、端口号、数据 InetAddress address = packet.getAddress(); int port = packet.getPort(); byte[] data2 = "欢迎您！".getBytes(); //创建数据报，包含响应信息 DatagramPacket packet2 = new DatagramPacket(data2, data2.length, address, port); //响应客户端 socket.send(packet2); //关闭资源 socket.close();&#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 客户端1234567891011121314151617181920212223242526/* * 向服务器端发送数据 *///定义服务器地址，端口号，发送数据InetAddress address = InetAddress.getByName("localhost");int port = 8800;byte[] data = "用户名：admin;密码：123".getBytes();//创建数据报，包含发送的信息DatagramPacket packet = new DatagramPacket(data, data.length, address, port);//创建DatagramSocket对象DatagramSocket socket = new DatagramSocket();//向服务器端发送数据报socket.send(packet);/* * 接收服务器端响应的数据 *///创建数据报，用于接收服务器响应数据byte[] data2 = new byte[1024];DatagramPacket packet2 = new DatagramPacket(data2, data2.length);//接收服务器响应的数据socket.receive(packet2);//读取数据String reply = new String(data2, 0, packet2.getLength());System.out.println("我是客户端，服务器说：" + reply);//关闭资源socket.close(); 总结 实际使用中，不传递字符串，而是封装为一个对象进行传输，将对象的序列化，然后传输 传递文件，通过IO输入输出流，读取文件数据，然后进行传输]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程服务器]]></title>
      <url>%2F2016%2F12%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[应用多线程来实现服务器与多客户端之间的通信基本步骤： 服务器端创建ServerSocket，循环调用accept()等待客户端连接 客户端创建一个socket并请求和服务器端连接 服务器端接受客户端请求，创建socket与该客户建立专线连接 建立连接的两个socket在一个单独的线程上对话 服务器端继续等待新的连接 多线程的优先级未设置优先级可能会导致运行时速度非常慢，可降低优先级thread.setPriority(4)//设置线程优先级，范围为[1,10]，默认为5 是否关闭输出流和输入流1234567891011121314Socket socket = new Socket("localhost", 8888);OutputStream os = socket.getOutputStream();PrintWriter pw = new PrintWriter(os);pw.write("内容");pw.flush();//pw.close();//不能关闭输出流，会导致socket也被关闭BufferedReader br = new BufferedReader(new InputStreamReader( socket.getInputStream()));String info = br.readLine();while(info != null)&#123; System.out.println("我是客户端，服务器说：" + info); info = br.readLine();&#125;socket.close();//直接关闭socket即可 对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket实现TCP通信]]></title>
      <url>%2F2016%2F12%2F04%2FSocket%E5%AE%9E%E7%8E%B0TCP%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[服务器端： 创建ServerSocket对象，绑定监听端口 通过accept()方法监听客户端请求 连接建立后，通过输入流读取客户端发送的请求信息 通过输出流向客户端发送响应信息 关闭相关资源 客户端： 创建Socket对象，指明需要连接的服务器的地址和端口号 连接建立后，通过输出流向服务器端发送请求信息 通过输入流获取服务器响应的信息 关闭相应资源 代码服务器端1234567891011121314151617181920212223242526272829303132try &#123; ServerSocket serverSocket = new ServerSocket(8888); //调用accept()方法开始监听 System.out.println("***服务器即将启动，等待客户端的连接***"); Socket socket = serverSocket.accept(); //获取输入流 InputStream is = socket.getInputStream();//字节输入流 InputStreamReader isr = new InputStreamReader(is);//将字节流转换为字符流 BufferedReader br = new BufferedReader(isr);//为输入流添加缓冲 String info = null; while((info = br.readLine()) != null)&#123;//循环读取客户端的信息 System.out.println("我是服务器，客户端说：" + info); &#125; socket.shutdownInput();//关闭输入流 //获取输出流，响应客户端请求 OutputStream os = socket.getOutputStream(); PrintWriter pw = new PrintWriter(os); pw.write("服务器的响应"); pw.flush(); socket.shutdownOutput(); pw.close(); os.close(); br.close(); isr.close(); is.close(); socket.close(); serverSocket.close();&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 客户端123456789101112131415161718192021222324252627282930313233try &#123; //创建客户端Socket，指定服务器地址和端口 Socket socket = new Socket("localhost", 8888); //获取输出流，向服务器发送信息 OutputStream os = socket.getOutputStream();//字节输出流 PrintWriter pw = new PrintWriter(os);//将输出流包装为打印流 pw.write("用户名：admin;密码：123"); pw.flush(); socket.shutdownOutput();//关闭输出流 InputStream is = socket.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String info = null; while((info = br.readLine()) != null)&#123; System.out.println("我是客户端，服务器说：" + info); info = br.readLine(); &#125; socket.shutdownInput(); br.close(); isr.close(); is.close(); pw.close(); os.close(); socket.close();&#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[四种XML解析方式比较]]></title>
      <url>%2F2016%2F12%2F04%2F%E5%9B%9B%E7%A7%8DXML%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[优缺点比较 DOM：基础方法，平台无关的官方解析方式 SAX：基础方法，基于事件驱动的解析方式 JDOM、DOM4j：在基础的方法上扩展出的，只有在java中能够使用的解析方法 DOM：一次性将整个XML文件加载入内存，如果文件较大则对性能要求高 SAX：基于事件驱动，会根据XML文件内容逐条解析 &lt;?xml?&gt;标签触发startDocument()方法 每个开始标签触发startElement()方法 每个结束标签触发endElement()方法 到根节点的结束标签后触发endDocument()方法 DOM 优点： 形成了树结构，直观好理解，代码更容易编写 解析过程中树结构保留在内存中，方便修改 缺点： 当XML文件较大时，对内存耗费比较大，容易影响解析性能并造成内存溢出 SAX 优点： 采用事件驱动模式，对内存耗费比较小 适用于只需要处理XML中数据时，不管树结构的时候 缺点： 不易编码 很难同时访问同一个XML中的多处不同数据 JDOM 仅使用具体类而不使用接口 API大量使用了Collections类 DOM4J JDOM的一种智能分支，它合并了许多超出基本XML文档表示的功能 DOM4J使用接口和抽象基本类方法，是一个优秀的Java XML API 具有性能优异、灵活性好、功能强大和极端易用使用的特点 是一个开放源代码的软件 性能测试使用JUnit的方法 右键项目名 点击Build Path下的Add Labraries 选择JUnit，版本选择JUnit 4 写一个测试方法，方法名随意，在方法名上一行加上@Test 有JUnit方法可以没有main()方法 测试过程 通过System.currentTimeMillis()方法记录一个开始时间 执行被测试的方法 通过System.currentTimeMillis()方法减去开始时间，即为被测试方法的执行时间 测试结果 DOM: 33 SAX: 6 JDOM: 69 DOM4J: 45 由于DOM要将整个XML装入内存中，所以DOM执行时间高于SAX当XML文件较大的时候，DOM解析容易产生内存溢出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jar包的导入]]></title>
      <url>%2F2016%2F12%2F04%2Fjar%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%2F</url>
      <content type="text"><![CDATA[目的避免项目迁移的时候，jar包不随着项目迁移 步骤 将jar包复制到项目中 右键项目，打开Build Path下的Configure Build Path 在Libraries选项卡中点击Add JARs 选择项目中的jar包，点击确定]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SAX解析XML]]></title>
      <url>%2F2016%2F12%2F04%2FSAX%E8%A7%A3%E6%9E%90XML%2F</url>
      <content type="text"><![CDATA[四种解析XML方法 DOM SAX DOM4J JDOM 步骤 通过SAXParserFactory的静态newInstance()方法获取SAXParserFactory实例factory 通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例parser 创建一个类继承DefaultHandler，重写其中的一些方法进行业务处理并创建这个类的实例handler 对XML文件解析的主要逻辑都在handler实例所属类中 示例12345678910111213141516171819202122232425262728293031//mainpublic static void main(String[] args) &#123; // 获取一个SAXParseFactory实例 SAXParserFactory factory = SAXParserFactory.newInstance(); //通过factory获取SAXParse实例 try &#123; SAXParser parser = factory.newSAXParser(); //创建SAXParserHandler对象 SAXParserHandler handler = new SAXParserHandler(); parser.parse("books.xml", handler); System.out.println("~~~共有" + handler.getBookList().size() + "本书"); for (Book book : handler.getBookList()) &#123; System.out.println(book.getId()); System.out.println(book.getName()); System.out.println(book.getAuthor()); System.out.println(book.getYear()); System.out.println(book.getPrice()); System.out.println(book.getLanguage()); System.out.println("---finish---"); &#125; &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 1234567891011121314151617//Book类public class Book &#123; private String id; private String name; private String author; private String year; private String price; private String language; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; //...省略get/set方法&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//SAXParserHandler类import java.util.ArrayList;import javax.xml.bind.ValidationEvent;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class SAXParserHandler extends DefaultHandler&#123; int bookIndex = 0; String value = null; Book book = null; private ArrayList&lt;Book&gt; bookList = new ArrayList&lt;Book&gt;(); public ArrayList&lt;Book&gt; getBookList() &#123; return bookList; &#125; /** * 用来标识解析开始 */ @Override public void startDocument() throws SAXException &#123; // TODO Auto-generated method stub super.startDocument(); System.out.println("SAX解析开始"); &#125; /** *用来标识解析结束 */ @Override public void endDocument() throws SAXException &#123; // TODO Auto-generated method stub super.endDocument(); System.out.println("SAX解析结束"); &#125; /** * 用来遍历xml文件的开始标签 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // TODO Auto-generated method stub super.startElement(uri, localName, qName, attributes); if(qName.equals("book"))&#123; book = new Book(); bookIndex++; System.out.println("===开始遍历第" + bookIndex + "本书的内容==="); //已知book元素下属性名称，根据属性名称获得属性值// String idValue = attributes.getValue("id");// System.out.println("book的属性值是：" + idValue); //不知道book元素下属性的名称及个数，获取属性名以及属性值 for(int i = 0; i &lt; attributes.getLength(); i++)&#123; System.out.print("book元素的第" + (i+1) + "个属性名是：" + attributes.getQName(i)); System.out.println("---属性值是：" + attributes.getValue(i)); if(attributes.getQName(i).equals("id"))&#123; book.setId(attributes.getValue(i)); &#125; &#125; &#125;else if(!qName.equals("book") &amp;&amp; !qName.equals("bookstore"))&#123; System.out.print("节点名：" + qName); &#125; &#125; /** * 用来遍历xml文件的结束标签 */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; // TODO Auto-generated method stub super.endElement(uri, localName, qName); //判断是否针对一本书已经遍历结束 if(qName.equals("book"))&#123; bookList.add(book); book = null; System.out.println("===结束遍历第" + bookIndex + "本书的内容==="); &#125;else if(qName.equals("name"))&#123; book.setName(value); &#125;else if(qName.equals("author"))&#123; book.setAuthor(value); &#125;else if(qName.equals("year"))&#123; book.setYear(value); &#125;else if(qName.equals("price"))&#123; book.setPrice(value); &#125;else if(qName.equals("language"))&#123; book.setLanguage(value); &#125; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // TODO Auto-generated method stub super.characters(ch, start, length); value = new String(ch, start, length); //清除空格 if(!value.trim().equals(""))&#123; System.out.println("---节点值：" + value); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO字符流]]></title>
      <url>%2F2016%2F12%2F04%2FIO%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
      <content type="text"><![CDATA[小结 编码问题 java的文本(char)是16位无符号整数，是字符的Unicode编码（双字节编码）文件是byte byte byte…的数据序列文本文件是文本(char)按照某种编码方案(utf-8,utf-16be,gbk)序列化为byte的存储结果 字符流(Reader Writer)—&gt;操作文本，文本文件字符的处理，一次处理一个字符字符的低层仍然是基本的字节序列 InputStreamReader 完成byte流解析为char流，按照编码解析OutputStreamWriter 提供char流到byte流，按照编码处理 FileReader/FileWriter 1234567891011121314151617181920FileInputStream in = new FileInputStream("f:\\1.txt");InputStreamReader isr = new InputStreamReader(in,"gbk");//不写"gbk"的话默认为项目编码FileOutputStream out = new FileOutputStream("f:\\2.txt");OutputStreamWriter osw = new OutputStreamWriter(out,"utf-8");/*int c;while((c=isr.read()) != -1)&#123; System.out.print((char)c);&#125;*/char[] buffer = new char[8*1024];int c;/*批量读取，放入buffer这个字符数组，从第0个位置开始放置，最多放buffer.length个*/while((c=isr.read(buffer,0,buffer.length)) != -1)&#123; String s = new String(buffer,0,c); System.out.print(s); osw.write(buffer,0,c); osw.flush();&#125;isr.close();osw.close(); FileReader/FileWriter 123456789101112FileReader fr = new FileReader("f:\\1.txt");FileWriter fw = new FileWriter("f:\\2.txt");//两个参数，第二个可选是否追加，不写为false//FileWriter fw = new FileWriter("f:\\2.txt",true);char[] buffer = new char[2056];int c;while((c=fr.read(buffer,0,buffer.length)) != -1)&#123; fw.write(buffer,0,c); fw.flush();&#125;fr.close();fw.close(); 字符流的过滤器BufferedReader –&gt;readLine 一次读一行BufferedWriter/PrintWriter –&gt;写一行 1234567891011121314151617181920//对文件进行读写操作BufferedReader br = new BufferedReader( new InputStreamReader( new FileInputStream("f:\\1.txt"),"gbk"));/*BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( new FileOutputStream("f:\\2.txt")));*/PrintWriter pw = new PrintWriter("f:\\3.txt");String line;while((line=br.readLine()) != null)&#123; System.out.println(line);//一次读一行，并不能识别换行符，这里的换行由println完成 /*bw.write(line); bw.newLine();//单独写换行 bw.flush();*/ pw.println(line);//println完成换行 pw.flush();&#125;br.close();//bw.close();pw.close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO字节流]]></title>
      <url>%2F2016%2F12%2F04%2FIO%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
      <content type="text"><![CDATA[InputStream 抽象了应用程序读取数据的方式，OutputStream 抽象了应用程序写出数据的方式 EOF = End 读到-1就读到结尾 输入流基本方法int b = in.read();读取一个字节，无符号填充到int的第8位。-1是 EOFin.read(byte[] buf);读取数据填充到字节数组bufin.read(byte[] buf, int start, int size);读取数据到字节数组，从buf的start位置开始，存放size长度数据，返回读到字节个数 输出流基本方法out.write(int b);写出一个byte到流，b的低8位out.write(byte[] buf);将buf字节数组都写入到流out.write(byte[] buf, int start, int size);字节数组buf从start位置开始，写size长度的字节到流 FileInputStream—&gt;具体实现了在文件上读取数据 FileOutputStream—&gt;实现了向文件中写出byte数据的方法 DataOutputStream/DataInputStream对“流”功能的扩展，可以更方便的读取int,long,字符等类型数据 BufferedInputStream/BufferedOutputStream这两个流类为IO提供了带缓冲区的操作，一般打开文件进行写入或读取操作，都会加上缓冲，这种流模式提高了IO的性能从应用程序中把数据放入文件FileOutputStream–&gt;write()方法按一个一个字节写DataOutputStream–&gt;writeXxx()方法会方便一些，对于int，long等数据减少代码量BufferedOutputStream–&gt;write()方法更方便，先把数据放到缓冲区中，再写入 文件拷贝效率比较效率排序 FileInputStream的批量读取in.read(byte[],start,size)，FileOutputStream的批量写入out.write(byte[],start,size) BufferedInputStream读取bis.read()，BufferedOutputStream写入bos.write(byteCount) FileInputStream单字节读取in.read()，FileOutputStream写入out.write(byte) FileInputStream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 读取指定文件内容，按照16进制输出到控制台 * 并且每输出10个byte换行 * 单字节读取不适合大文件，大文件效率很低 * @param fileName */ public static void printHex(String fileName)throws IOException&#123; FileInputStream in = new FileInputStream(fileName); int b; int i = 1; while ((b = in.read()) != -1) &#123; //如果的单位的数，前面补0 if(b &lt;= 0xf)&#123; System.out.print("0"); &#125; System.out.print(Integer.toHexString(b) + " "); if(i++ % 10 == 0)&#123; System.out.println(); &#125; &#125; in.close(); &#125; /** * 批量读取，对大文件而言效率高，也是我们最常用的读文件的方式 * @param fileName * @throws IOException */ public static void printHexByBytes(String fileName)throws IOException&#123; FileInputStream in = new FileInputStream(fileName); byte[] buf = new byte[8 * 1024];//8KB /* 从in中批量读取字节，放入到buf这个字节数组中， * 从第0个位置开始放，最多放buf.length个 * 返回的是读到字节的个数 */ /*int j = 1; int bytes = in.read(buf, 0, buf.length);//一次性读完，说明字节数组足够大 for(int i = 0; i &lt; bytes; i++)&#123; if(buf[i] &lt;= 0xf)&#123; System.out.print("X"); &#125; System.out.print(Integer.toHexString(buf[i] &amp; 0xff) + " "); if(j++ % 10 == 0)&#123; System.out.println(); &#125; &#125;*/ int bytes = 0; int j = 1; while((bytes = in.read(buf,0,buf.length)) != -1)&#123; for(int i = 0; i &lt; bytes; i++)&#123; if(buf[i] &lt; 0xf)&#123; System.out.print("0"); &#125; //byte类型8位，int类型32位，为避免转换错误，通过 &amp;0xff 将高24位清零 System.out.print(Integer.toHexString(buf[i] &amp; 0xff) + " "); if(j++ % 10 == 0)&#123; System.out.println(); &#125; &#125; &#125; &#125; FileOutputStream12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args)throws IOException&#123; //如果文件不存在，直接创建，如果存在，删除后创建 FileOutputStream out = new FileOutputStream("test.dat"); /*文件存在，不删除，在文件内容后面追加 FileOutputStream out = new FileOutputStream("test.dat",true);*/ out.write('B');//只写'A'的低八位 int a = 10;//write只能写低八位，所以写一个int需要写4次 out.write(a &gt;&gt;&gt; 24); out.write(a &gt;&gt;&gt; 16); out.write(a &gt;&gt;&gt; 8); out.write(a); byte[] gbk = "中国".getBytes("gbk"); out.write(gbk); out.close(); IOUtil.printHex("test.dat");&#125;/** * 文件拷贝 * @param srcFile * @param destFile * @throws IOException */public static void copyFile(File srcFile, File destFile)throws IOException&#123; if(!srcFile.exists())&#123; throw new IllegalArgumentException("文件" + srcFile + "不存在"); &#125; if(srcFile.isDirectory())&#123; throw new IllegalArgumentException(srcFile + "不是文件"); &#125; FileInputStream in = new FileInputStream(srcFile); FileOutputStream out = new FileOutputStream(destFile); byte[] buf = new byte[8*1024]; int b; while((b=in.read(buf, 0, buf.length)) != -1)&#123; out.write(buf, 0, b); out.flush();//最好加上 &#125; in.close(); out.close();&#125; DataOutputStream1234567891011String file = "f:\\java.dat";DataOutputStream dos = new DataOutputStream( new FileOutputStream(file));dos.writeInt(10);dos.writeLong(10l);dos.writeDouble(10.5);//UTF-8编码dos.writeUTF("张三");//UTF-16be编码dos.writeChars("张三");dos.close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RandomAccessFile]]></title>
      <url>%2F2016%2F12%2F04%2FRandomAccessFile%2F</url>
      <content type="text"><![CDATA[java提供的对文件内容的访问，既可以读文件，也可以写文件。支持随机访问文件，可以访问文件的任意位置 步骤 java文件模型 在硬盘上的文件是 byte byte byte 存储的，是数据的集合 打开文件 有两种模式 “rw”（读写） “r”（只读） RandomAccessFile raf = new RandowAccessFile(file,”rw”) 文件指针，打开文件时指针在开头 pointer = 0; 写方法 raf.write(int)–&gt;只写一个字节（后8位），同时指针指向下一个位置，准备再次写入 读方法 int b = raf.read()–&gt;读一个字节 文件读写完成以后一定要关闭（Oracle官方说明） 123456789101112131415161718192021222324252627282930313233File file = new File("d:\\test.txt");RandomAccessFile raf = new RandowAccessFile(file,"rw");System.out.println(raf.getFilePointer());//指针位置raf.write('A');//只写了一个字节，后8位，并不是整个charSystem.out.println(raf.getFilePointer());//指针位置+1int i = 0x7fffffff;//int最大值，首位为0表示符号位，其他都为1//用write方法每次只能写一个字节，如果要把i写进去就得写4次raf.write(i &gt;&gt;&gt; 24);//高8位raf.write(i &gt;&gt;&gt; 16);raf.write(i &gt;&gt;&gt; 8);raf.write(i);//最后8位//可以直接写一个intraf.writeInt(i);//writeInt()方法与上面写法基本相同。String s = "中";byte[] gbk = s.getBytes("gbk");raf.write(gbk);//读文件，必须把指针移到头部raf.seek(0);//一次性读取，把文件中的内容都读到字节数组中//因为文件存储是byte byte byte，所以用字节数组byte[] buf = new byte[(int)raf.length()];raf.read(buf);System.out.print(Arrays.toString(buf));for(byte b : buf)&#123; System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;raf.close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java.io.File类的使用]]></title>
      <url>%2F2016%2F12%2F04%2FJava-io-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[File类只用于表示文件（目录）的信息（名称、大小等），不能用于文件内容的访问 对目录操作 1234567File file = new File("D:\\aaa");file.exists(); //判断该目录是否存在file.mkdir(); //创建该目录file.mkdirs(); //当创建多级目录时使用file.delete(); //删除该目录file.isDirectory(); //判断是否是一个目录，如果目录不存在也返回falsefile.isFile(); //判断是否是一个文件 创建文件1234567891011//File file = new File("d:\\dir\\1.txt"); 两种方法皆可File file = new File("d:\\dir","1.txt");try&#123; file.createNewFile(); //创建1.txt文件&#125; catch (IOException e) &#123; e.printStackTrace();&#125;System.out.println(file); //打印 file.toString() 内容file.getAbsolutePath(); //与 file 相同file.getName(); // file为目录时打印最后一个目录，为文件时打印文件名file.getParent(); //返回父目录 遍历目录12345678910111213141516171819202122232425262728293031323334import java.io.File;import java.io.IOException;public class FileUtils &#123; /** * 列出子目录下（包括其子目录）的所有文件 * @param dir * @throws IOException */ public static void listDirectory(File dir)throws IOException&#123; if(!dir.exists())&#123; throw new IllegalArgumentException("目录：" + dir + "不存在."); &#125; if(!dir.isDirectory())&#123; throw new IllegalArgumentException(dir + "不是目录."); &#125; //dir.list(); 返回的是字符串数组，直接子目录或文件的名称，不包含子目录的内容 //如果要遍历子目录下的内容就需要构造File对象进行递归操作，File类提供了直接返回File对象的方法 File[] files = dir.listFiles();//返回的是直接子目录（文件）的抽象 if(files != null &amp;&amp; files.length &gt; 0)&#123; for (File file : files) &#123; if(file.isDirectory())&#123; //递归 listDirectory(file); &#125; else&#123; System.out.println(file); &#125; &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java文件编码]]></title>
      <url>%2F2016%2F12%2F03%2FJava%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627String s = "张三Ab1";//转换成字节序列用的是项目默认编码(gbk)，等同于 s.getBytes("gbk")byte[] bytes1 = s.getBytes();for(byte b : bytes1)&#123; //byte转换成int，把后8位前面加上24个0，变成32位 //位与上 0xff 去掉前面24个0 System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：d5 c5 c8 fd 41 62 31// 张 三 A b 1//gbk编码中文占2字节，英文占1字节//转换成utf-8编码byte[] bytes2 = s.getBytes("utf-8");for(byte b : bytes2)&#123; System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：e5 bc a0 e4 b8 89 41 62 31//utf-8编码中文占3字节，英文占1字节//Java是双字节编码 utf-16bebyte[] bytes3 = s.getBytes("utf-16be");for(byte b : bytes3)&#123; System.out.print(Integer.toHexString(b &amp; 0xff) + " ");&#125;//输出结果：5f 20 4e 9 0 41 0 62 0 31//utf-16be编码中文英文都占2字节 当字节序列是某种编码时，如果要转换成字符串，也需要用这种编码方式，否则出现乱码，不指明编码方式时用项目默认编码方式。 123456String s = "张三";byte[] bytes = s.getBytes(utf-16be);String str1 = new String(bytes); //用项目默认编码方式（gbk），输出乱码String str2 = new String(bytes,"utf-16be"); //用utf-16be编码，输出正常System.out.print(str1); //输出乱码System.out.print(str2); //输出正常e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript正则表达式笔记]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[RegExp对象两种方法实例化RegExp对象 字面量 构造函数 字面量 将文本写在两个斜线”/“之间 1var reg = /\bis\b/g; 构造函数 使用 new RegExp()出一个对象 12var reg = new RegExp('\\bis\\b','g');// 这里的"\\b"是因为转义字符。 修饰符 g:global全文搜索，不添加，搜索到第一个匹配停止，默认false i:ignore case忽略大小写，默认大小写敏感，默认false m:multiple lines多行搜索，默认false 元字符 正则表达式由两种基本字符类型组成: 原义文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符* + ? $ ^ . | \ ( ) { } [ ] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX 与X对应的控制字符（Ctrl+X） 字符类 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符 字符类取反 使用元字符 ^ 创建 反向类/负向类 反向类的意思是不属于某类的内容 表达式 [^abc] 表示不是字符a或b或c的内容 范围类 可以使用 [a-z] 来连接两个字符表示从a到z的任意字符 这是一个闭区间，包含a和z本身 在 [] 组成的类内部是可以连写的 [a-zA-Z] 预定义类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 digit \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 space \S [^\t\n\x0B\f\r] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字下划线） word \W [^a-zA-Z_0-9] 非单词字符 匹配一个 ab+数字+任意字符 的字符串ab\d. 边界 字符 含义 ^ 以xxx开始 $ 以xxx结束 \b 单词边界 \B 非单词边界 量词 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式\d{3,6} 匹配最多的6次‘123456789’.replace(/\d{3,6}/g, ‘X’) 结果为 “X789” 非贪婪模式在量词后加上 ? 即可‘123456789’.match(/\d{3,5}?/g) 结果为 [“123”,”456”,”789”]‘12345678’.replace(/\d{3,6}?/g, ‘X’) 结果为 “XX78” 分组 Byron连续出现3次：Byron{3}含义为 “Byro” “n”重复3次两次作用于紧挨着的 “n” 使用()可以达到分组的功能，使两次作用于分组(Byron){3} 即可 或 使用 | 可达到或的效果Byr(on|Ca)sper 匹配on或者Ca 反向引用 2015-12-25 =&gt; 12/25/2015‘2015-12-25’.replace(/(\d{4})-(\d{2})-(\d{2})/g, ‘$2/$3/$1’) 忽略分组 不希望捕获某些分组，只需要在分组内加上 ?: 就可以(?:Byron).(ok)这时的 $1 为 ok 前瞻 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前” 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反 JavaScript不支持后顾 符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配 名称 正则 含义 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向后顾 exp(?&lt;=assert) JavaScript不支持 负向后顾 exp(?&lt;!assert) JavaScript不支持 正向前瞻‘a234v8’.replace(/\w(?=\d)/g, ‘X’) 结果为 “X2X4X8”‘a234vv’.replace(/\w(?=\d)/g, ‘X’) 结果为 “X2X4vv” 负向前瞻‘a234vv’.replace(/\w(?!\d)/g, ‘X’) 结果为 “aX3XXX” 对象属性 这几个属性是只读的 global:全文搜索，不添加，搜索到第一个匹配停止，默认false ignore case:忽略大小写，默认大小写敏感，默认false multiline:多行搜索，默认false lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置 source:正则表达式的文本字符串 RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在返回true，否则返回false 12345var reg1 = /\w/;var reg2 = /\w/g;reg1.test('a'); //执行多次结果均为truereg2.test('a'); //执行多次结果为true,false,true,false... 当加上g之后，每次搜索会影响到lastIndex属性的值，会从lastIndex开始 RegExp.prototype.exec(str) 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符的位置 input 存放被检索的字符串 string 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式（就是分组）相匹配的文本（如果有的话） 第三个元素是与RegExp对象的第二个子表达式（就是分组）相匹配的文本（如果有的话），依此类推 String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果index，查找不到返回 -1 search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索 String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与RegExp相匹配的文本 regexp是否具有标志g对结果影响很大 非全局调用 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性 index 声明匹配文本的起始字符在字符串的位置 input 声明对stringObject的引用 全局调用 如果regexp具有标志g则match()方法将执行全局检索，找到字符串中的所有匹配子字符串 没有找到任何匹配的子串，则返回null 如果找到了一个或多个匹配子串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 String.prototype.split(reg) 我们经常使用split方法把字符串分割为字符数组 ‘a,b,c,d’.split(‘,’); //[“a”,”b”,”c”,”d”] 在一些复杂的分割情况下我们可以使用正则表达式解决 ‘a1b2c3d’.split(/\d/); //[“a”,”b”,”c”,”d”] String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function参数含义 function会在每次匹配替换的时候调用，有四个参数 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的index 原字符串 ‘a1b2c3d4e5’ =&gt; ‘a2b3c4d5e6’123'a1b2c3d4e5'.replace(/\d/g, function(match,index,origin)&#123; return parseInt(match) + 1;&#125;); ‘a1b2c3d4e5’ =&gt; ‘a12c34e5’ 去掉\d\w\d中的\w123'a1b2c3d4e5'.replace(/(\d)(\w)(\d)/, function(match,group1,group2,group3,index,origin)&#123; return group1 + group3;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记（二）]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[定义数组123456789101112131415var myarr1 = new Array();var myarr2 = new Array(5); //虽然指定长度，但是可以增加var myarr3 = new Array(10,20,30,40,50);var myarr4 = [10,20,30,40,50]; //直接输入一个数组（称“字面量数组”）//声明二维数组方法一var myarr = new Array();for(var i=0;i&lt;2;i++)&#123; myarr[i] = new Array(); for(var j=0;j&lt;3;j++) &#123; myarr[i][j]=i+j; &#125;&#125;var myArr = [[0,1,2],[3,4,5]]//声明二维数组方法二 事件主要事件表 事件 说明 onclick 鼠标单击事件 onmouseover 鼠标经过事件 onmouseout 鼠标移开事件 onchange 文本框内容改变事件 onselect 文本框内容被选中事件 onfocus 光标聚集 onblur 光标离开 onload 网页导入 写在body标签内 onunload 关闭网页 日期对象Date常用方法 方法名称 功能描述 get/setDate() 返回/设置日期 get/setFullYear() 返回/设置年份，用四位数表示 get/setYear() 返回/设置年份 get/setMonth() 返回/设置月份。0:一月…11:十二月 get/setHours() 返回/设置小时，24小时制 get/setMinutes() 返回/设置分钟数 get/setSeconds() 返回/设置秒钟数 get/setTime() 返回/设置时间（毫秒为单位） getDay() 返回星期，返回的是数字，0表示星期天 字符串对象Stringlength属性:返回字符串长度 方法名称 功能描述 参数描述 toUpperCase() 转换为大写 toLowerCase() 转换为小写 charAt(index) 返回指定位置的字符 整型，下标，从0开始 indexOf(substring, startpos) 返回指定字符串值在字符串中首次出现的位置 substring:字符串，必需，规定需检索的字符串。startpos:整型，规定开始检索的位置，从0到length-1之间，省略则从0开始 split(separator,limit) 分割为字符串数组，并返回此数组 separator:字符串，必需，从指定地方开始分割。limit:整型，分割次数，如果无此参数则不限制次数 substring(starPos,stopPos) 提取字符串中两个指定下标之间的字符 startPos:整型，必需，开始位置。stopPos:整型，可选，结束位置 substr(startPos,length) 提取字符串中从开始位置的指定数目的字符串 startPos:整型，必需，开始位置，如果为负数则倒数，-1是最后一个字符，-2是倒数第二个。length:整型，可选，字符串长度 Math对象内置对象，直接使用 属性 说明 E 返回算术常量e，即自然对数的底数（约等于2.718） LN2 返回2的自然对数（约等于0.693） LN10 返回10的自然对数（约等于2.302） LOG2E 返回以2为底的e的对数（约等于1.442） LOG10E 返回以10为底的e的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回2的平方根的倒数（约等于0.707） SQRT2 返回2的平方根（约等于1.414） 方法 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值 asin(x) 返回数的反正弦值 atan(x) 返回数的反正切值 atan2(y,x) 返回由x轴到点(x,y)的角度（以弧度为单位） ceil(x) 对数进行上舍入 cos(x) 返回数的余弦 exp(x) 返回e的指数 floor(x) 对数进行下舍入 log(x) 返回数的自然对数（底为e） max(x,y) 返回x和y中的最高值 min(x,y) 返回x和y中的最低值 pow(x,y) 返回x的y次幂 random() 返回0~1之间的随机数 [0,1) round(x) 把数四舍五入为最接近的整数 sin(x) 返回数的正弦 sqrt(x) 返回数的平方根 tan(x) 返回角的正切 toSource() 返回该对象的源代码 valueOf() 返回Math对象的原始值 数组对象 方法 描述 concat(arr1,arr2,…,arrN) 连接两个或更多的数组，并返回一个新数组 join(separator) 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分割，参数省略则用逗号分割 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 颠倒数组中元素的顺序 shift() 删除并返回数组的第一个元素 slice(start,end) 从某个已有的数组返回选定的元素 sort(方法函数) 对数组的元素进行排序，如果不指定&lt;方法函数&gt;，则按Unicode码顺序排列 splice() 删除元素，并像数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串，并返回结果 toLocaleString() 把数组转换为本地数组，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值 sort()使用说明 比较函数具有两个参数A和B，返回值如下： 若返回值 (-无穷,-1]，则表示A在排序后的序列中出现在B之前 若返回值 (-1,1)，则表示A和B具有相同的排序顺序 若返回值 [1,+无穷)，则表示A在排序后的序列中出现在B之后 12345678910//不带参数&lt;script type="text/javascript"&gt; var myarr1 = new Array("Hello","John","love","Javascript"); var myarr2 = new Array("80","16","50","6","100","1"); document.write(myarr1.sort() + "&lt;br /&gt;"); document.write(myarr2.sort()); //运行结果 //Hello,JavaScript,John,love //1,100,16,50,6,80&lt;/script&gt; 1234567891011121314//带参数&lt;script type="text/javascript"&gt; function sortNum(a,b) &#123; return a - b; //升序，如降序，改为"b - a" &#125; var myarr = new Array("80","16","50","6","100","1"); document.write(myarr + "&lt;br /&gt;"); document.write(myarr.sort(sortNum)); //运行结果 //80,16,50,6,100,1 //1,6,16,50,80,100&lt;/script&gt; window对象 方法 描述 参数描述 示例 alert() 显示带有一段消息和一个确认按钮的警告框 prompt() 显示可提示用户输入的对话框 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 open([URL],[窗口名称],[参数字符串]) 打开一个新的浏览器窗口或查找一个已命名的窗口 具体用法见JavaScrip基础篇学习笔记 close() 关闭浏览器窗口 print() 打印当前窗口的内容 focus 把键盘焦点给予一个窗口 blur() 把键盘焦点从顶层窗口移开 moveBy() 可相对窗口的当前坐标把它移动指定的像素 moveTo() 把窗口的左上角移动到一个指定的坐标 resizeBy() 按照指定的像素调整窗口的大小 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素值来滚动内容 scrollTo() 把内容滚动到指定的坐标 setInterval(代码,交互时间) 每隔指定的时间执行代码 代码：要调用的函数或要执行的代码串。交互时间：以毫秒计 setInterval(“clock()”,1000);或setInterval(clock,1000); setTimeout(代码,延迟时间) 在指定的延迟时间之后来执行代码 代码：要调用的函数或要执行的代码串。延迟时间:执行代码前等待的时间，毫秒计 clearInterval(id_of_setInterval) 取消setInterval()的设置 id_of_setInterval:由setInterval()返回的ID值 var i = setInterval(“clock()”, 1000); clearInterval(i); clearTimeout(id_of_setTimeout) 取消setTimeout()的设置 id_of_setInterval:由setTimeout()返回的ID值 History对象语法12window.history.[属性|方法]//window可以省略 属性 属性 描述 length 返回浏览器历史列表中的URL数量 方法 方法 描述 备注 back() 加载history列表中的前一个URL 相当于history.go(-1) forward() 加载history列表中的下一个URL 相当于history.go(1) go(number) 加载history列表中的某个具体的页面 0为当前页面,其他数值为history的URL列表中的相对位置 Location对象语法1location.[属性|方法] 属性 设URL为：http://www.imooc.com:8080/list.php?courseid=8#mediaid118 属性 描述 属性对应内容 hash 设置或返回从井号(#)开始的URL(锚) mediaid118 host 设置或返回主机名和当前URL的端口号 www.imooc.com:8080 hostname 设置或返回当前URL的主机名 www.imooc.com href 设置或返回完整的URL http://www.imooc.com:8080/list.php?courseid=8#mediaid118 pathname 设置或返回当前URL的路径部分 list.php port 设置或返回当前URL的端口号 8080 protocol 设置或返回当前URL的协议 http: search 设置或返回从问号(?)开始的URL(查询部分) courseid=8 方法 属性 描述 assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 Navigator对象属性 属性 描述 appCodeName 浏览器代码名的字符串表示 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent头部的值 screen对象语法1window.screen.属性 对象属性 属性 描述 availHeight 窗口可以使用的屏幕高度，单位像素 availWidth 窗口可以使用的屏幕宽度，单位像素 colorDepth 用户浏览器表示的颜色位数，通常为32位(每像素的位数) pixelDepth 用户浏览器表示的颜色位数，通常为32位(IE不支持此属性) height 屏幕分辨率的高度，单位像素 width 屏幕分辨率的宽度，单位像素 文档对象模型DOM(Document Object Model)DOM节点有： 元素节点：&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等，即标签。 文本节点：向用户展示的内容。 属性节点：元素属性。 节点属性 方法 说明 nodeName 返回一个字符串，其内容是给定节点的名字。 nodeType 返回一个整数，这个数值代表给定节点的类型 nodeValue 返回给定节点的当前值 nodeName属性：节点的名称，是只读的。 元素节点的nodeName与标签名相同 属性节点的nodeName是属性的名称 文本节点的nodeName永远是#text 文档节点的nodeName永远是#document nodeValue属性：节点的值 元素节点的nodeValue是undefined或null 文本节点的nodeValue是文本自身 属性节点的nodeValue是属性的值 nodeType属性：节点的类型，是只读的。以下常用几种节点类型： 元素：1 属性：2 文本：3 注释：4 文档：5 遍历节点树 方法 说明 备注 childNodes 返回一个数组，这个数组由给定元素节点的子节点构成。 firstChild 返回第一个子节点，没有子节点则返回null 与childNodes[0]等同 lastChild 返回最后一个子节点，没有子节点则返回null 与childNodes[childNodes.length-1]等同 parentNode 返回一个给定节点的父节点 nextSibling 返回给定节点的下一个子节点 previousSibling 返回给定节点的上一个子节点 DOM操作 方法 说明 createElement(element) 创建一个新的元素节点 createTextNode() 创建一个包含着给定文本的新文本节点 appendChild() 指定节点的最后一个子节点列表之后添加一个新的子节点 insertBefore() 将一个给定节点插入到一个给定元素节点的给定子节点的前面 removeChild() 从一个给定元素中删除一个子节点 replaceChild() 把一个给定父元素里的一个子节点替换为另外一个子节点 getElementsByName()方法语法 1document.getElementsByName(name); 注意 因为文档中name属性可能不唯一，所以getElementsByName()方法返回的元素是数组，而不是一个元素。 和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。 getElementsByTagName()方法语法 1document.getElementsByTagName(Tagname); 说明 Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 getAttribute()方法语法 1elementNode.getAttribute(name); 说明 elementNode:使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。 name:要想查询的元素节点的属性名字。 setAttribute()方法语法 1elementNode.setAttribute(name,value); 说明 name:要设置的属性名 value:要设置的属性值 注意 把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 访问子节点childNodes语法 1elementNode.childNodes; 注意 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 示例 12345678910&lt;ul&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;li&gt;jQuery&lt;/li&gt; &lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var x=document.getElementsByTagName("ul")[0].childNodes; document.write("UL子节点个数："+x.length+"&lt;br /&gt;"); document.write("节点类型："+x[0].nodeType);&lt;/script&gt; 运行结果： IE： 12UL子节点个数：3节点类型：1 其它浏览器： 12UL子节点个数：7节点类型：3 注意 IE全系列、firefox、chrome、opera、safari兼容问题 节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7 12345&lt;ul&gt;&lt;!--空白节点--&gt; &lt;li&gt;javascript&lt;/li&gt;&lt;!--空白节点--&gt; &lt;li&gt;jQuery&lt;/li&gt;&lt;!--空白节点--&gt; &lt;li&gt;PHP&lt;/li&gt;&lt;!--空白节点--&gt;&lt;/ul&gt; 如果把代码改成这样 1&lt;ul&gt;&lt;li&gt;javascript&lt;/li&gt;&lt;li&gt;jQuery&lt;li&gt;&lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt; 运行结果：（IE和其它浏览器结果是一样的） 12UL子节点个数：3节点类型：1 firstChild和lastChild firstChild等同于elementNode.childNodes[0] lastChild等同于elementNode.childNodes[elementNode.childNodes.length-1] 如果没有子节点则返回null parentNode父节点只能有一个 语法 1elementNode.parentNode 访问兄弟节点 nextSibling属性可返回某个节点之后紧跟的节点 1nodeObject.nextSibling previousSibling属性可返回某个节点之前紧跟的节点 1nodeObject.previousSibling 注意 两个属性获取的是节点。Internet Explorer会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。 解决问题方法：判断节点nodeType是否为1 插入节点appendChild()语法 1appendChild(newnode) 示例 1234567&lt;div id="test"&gt;&lt;p id="x1"&gt;HTML&lt;/p&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest = document.getElementById("test"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; otest.appendChild(newnode);&lt;/script&gt; 插入节点insertBefore()语法 1insertBefore(newnode,node); 参数 newnode:要插入的新节点 node:指定此节点前插入节点 123456789&lt;div id="test"&gt;&lt;p id="x1"&gt;HTML&lt;/p&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest = document.getElementById("test"); var node = document.getElementById("x1"); var newnode = document.createElement("p"); newnode.innerHTML = "This is a new p"; otest.insertBefore(newnode,node); //或者otest.insertBefore(newnode,otest.childNodes[0]);&lt;/script&gt; 删除节点removeChild()如删除成功，则返回被删除的节点，如失败，则返回NULL 语法 1nodeObject.removeChild(node) 示例 123456&lt;div id="div1"&gt;&lt;h1&gt;HTML&lt;/h1&gt;&lt;h2&gt;javascript&lt;/h2&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var otest=document.getElementById("div1"); var x=otest.removeChild(otest.childNodes[1]); document.write("删除节点的内容："+x.innerHTML);&lt;/script&gt; 注意 把删除的子节点赋值给x，这个子节点不在DOM树中，但是还存在内存中，可通过x操作如果要完全删除对象，给x赋值null值。 替换元素节点replaceChild()replaceChild实现子节点（对象）的替换。返回被替换对象的引用 语法1node.replaceChild(newnode,oldnew) 参数 newnode:必需，用于替换oldnew对象 oldnew:必需，被newnode替换的对象。 示例 123456789101112&lt;script type="text/javascript"&gt; function replaceMessage() &#123; var newnode=document.createElement("p"); var newnodeText=document.createTextNode("JavaScript"); newnode.appendChild(newnodeText); var oldNode=document.getElementById("oldnode"); oldNode.parentNode.replaceChild(newnode,oldNode); &#125;&lt;/script&gt;&lt;h1 id="oldnode"&gt;Java&lt;/h1&gt;&lt;a href="javascript:replaceMessage()"&gt;"Java"改为"JavaScript"&lt;/a&gt; 注意 当oldnode被替换时，所有与之相关的属性内容都将被移除 newnode必须先被建立 创建元素节点createElementcreateElement()方法可创建元素节点。此方法可返回一个Element对象 语法 1document.createElement(tagName) 参数 tagName:字符串值，这个字符串用来指明创建元素的类型 注意 要与appendChild()或insertBefore()方法联合使用，将元素显示在页面中 创建文本节点createTextNodecreateTextNode()方法创建新的文本节点，返回新创建的Text节点 语法 1document.createTextNode(data) 参数 data:字符串值，可规定此节点的文本 浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera以及Safari: window.innerHeight:浏览器窗口的内部高度 window.innerWidth:浏览器窗口的内部宽度 对于Internet Explorer8、7、6、5: document.documentElement.clientHeight表示HTML文档所在窗口的当前高度 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度 或者 Document对象的body属性对应HTML文档的&lt;body&gt;标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的JavaScript方案： 12var w = document.documentElement.clientWidth || document.body.clientWidth;var h = document.documentElement.clientHeight || document.body.clientHeight; 网页尺寸scrollHeightscrollHeight和scrollWidth，获取网页内容高度和宽度 针对IE、Opera： scrollHeight是网页内容实际高度，可以小于clientHeight。 针对NS、FF: scrollHeight是网页内容高度，不过最小值是clientHeight。也就是说网页内容实际高度小于clientHeight时，scrollHeight返回clientHeight。 浏览器兼容性12var w = document.documentElement.scrollWidth || document.body.scrollWidth;var h = document.documentElement.scrollHeight || document.body.scrollHeight; scrollHeight和scrollWidth还可获取DOM元素中内容实际占用的高度和宽度 网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度（包括滚动条等边线，会随窗口的显示大小改变） 值 offsetHeight = clientHeight + 滚动条 + 边框 浏览器兼容性 12var w = document.documentElement.offsetWidth || document.body.offsetWidth;var h = document.documentElement.offsetHeight || document.body.offsetHeight; 网页卷去的距离与偏移量 scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由offsetParent属性指定的父坐标的计算左侧位置。 offsetTop:获取指定对象相对于版面或由offsetParent属性指定的父坐标的计算顶端位置。 注意 offsetParent:布局中设置position属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记（一）]]></title>
      <url>%2F2016%2F12%2F03%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[保留字和关键字 关键字 break else new var case finally return void catch for switch while default if throw delete in try do instanceof typeof 保留字 abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 输出1document.write("输出的内容"); 消息对话框123alert(str); //一个确定按钮confirm(str);//确定，取消按钮,返回值为用户选择prompt(str1,str2);//确定，取消，输入框 窗口操作打开新窗口1window.open([URL],[窗口名称],[参数字符串]); URL：在窗口中要显示的路径 窗口名称： “_top”,”_blank”,”_self”这三个具有特殊意义，其余按正常命名规则取名。 _top:框架网页中在上部窗口中显示目标网页 _blank:在新窗口中显示目标网页 _self:在当前窗口显示目标网页 参数表 参数 值 说明 top Number 窗口顶部离开屏幕顶部的像素数 left Number 窗口左端离开屏幕左端的像素数 width Number 窗口的宽度 heitht Number 窗口的高度 menubar yes,no 窗口有没有菜单 toolbar yes,no 窗口有没有工具条 scrollbars yes,no 窗口有没有滚动条 status yes,no 窗口有没有状态栏 关闭窗口close()关闭窗口 用法： 12window.close(); //关闭本窗口&lt;窗口对象&gt;.close();//关闭指定的窗口 获取元素通过ID获取语法：1document.getElementById("id"); innerHTML属性用于获取或者替换HTML元素的内容。 语法： Object.innerHTML Object是通过document.getElementById(“id”)获取到的元素 注： innerHTML:从对象起始位置到终止位置的全部内容，包括HTML标签innerText:将innerHTML去除HTML标签outerHTML:除了innerHTML的内容外，还包含对象本身的标签特别：innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器，因此，尽可能地去使用innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：&lt;a href=&quot;javascript:alert(document.getElementById(&#39;test&#39;).innerHTML.replace(/&lt;.+?&gt;/gim,&#39;&#39;))&quot;&gt;无HTML,符合W3C标准&lt;/a&gt; 改变HTML样式语法：1Object.style.property = new style; 基本属性（property）：backgroundColor，height，width，color，font，fontFamily，fontSize等等 示例： 1myObject.style.color="red"; 显示和隐藏（display属性）语法：1Object.style.display = value; value的取值： 值 描述 none 此元素不会被显示（即隐藏） block 此元素将显示为块级元素（即显示） 示例：12myObject.style.display = "none"; //隐藏myObject.style.display = "block"; //显示 控制类名（className属性）语法：1Object.className = value; //value为class名 removeAttribute()删除之前应用的样式属性 语法：1Object.removeAttribute("style");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM生成XML文件]]></title>
      <url>%2F2016%2F12%2F03%2FDOM%E7%94%9F%E6%88%90XML%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[与JavaScrip中对DOM文档操作简直一毛一样 12345678910public DocumentBuilder getDocumentBuilder()&#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = null; try &#123; db = dbf.newDocumentBuilder(); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; return db;&#125; 123456789101112131415161718192021222324252627282930313233public void createXML()&#123; DocumentBuilder db = getDocumentBuilder(); Document document = db.newDocument(); //将XML文件第一行中的standalone="yes"，默认不显示 document.setXmlStandalone(true); //创建根节点 Element bookstore = document.createElement("bookstore"); //创建子节点 Element book = document.createElement("book"); //添加属性 book.setAttribute("id", "1"); Element name = document.createElement("name"); //添加文本 name.setTextContent("小王子"); book.appendChild(name); bookstore.appendChild(book); //将已经包含book节点的的bookstore节点添加到DOM树中 document.appendChild(bookstore); TransformerFactory tff = TransformerFactory.newInstance(); try &#123; Transformer tf = tff.newTransformer(); //换行 tf.setOutputProperty(OutputKeys.INDENT, "yes"); tf.transform(new DOMSource(document), new StreamResult(new File("books1.xml"))); &#125; catch (TransformerConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (TransformerException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM解析XML]]></title>
      <url>%2F2016%2F12%2F03%2FDOM%E8%A7%A3%E6%9E%90XML%2F</url>
      <content type="text"><![CDATA[四种解析方式 DOM SAX DOM4J JDOM 常用的节点类型 节点类型 NodeType Named Constant nodeName的返回值 nodeValue的返回值 Element 1 ELEMENT_NODE element name null Attr 2 ATTRIBUTE_NODE 属性名称 属性值 Text 3 TEXT_NODE #text 节点内容 DOM方式解析XML步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void main(String[] args) &#123; //创建一个DocumentBuilderFactory对象 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); try &#123; //创建DocumentBuilder对象 DocumentBuilder db = dbf.newDocumentBuilder(); //通过DocumentBuilder对象的parse方法加载books.xml文件到当前项目下 Document document = db.parse("books.xml"); //获取所有book节点的集合 NodeList bookList = document.getElementsByTagName("book"); //通过NodeList的getLength()方法可以获取bookList的长度 System.out.println("一共有" + bookList.getLength() + "本书"); //遍历每一个book节点 for(int i = 0; i &lt; bookList.getLength(); i++)&#123; System.out.println("===下面开始遍历第" + (i+1) + "本书的内容==="); //通过item(index)方法获取一个book节点，NodeList索引值从0开始 Node book = bookList.item(i); //获取book节点的所有属性集合 NamedNodeMap attrs = book.getAttributes(); System.out.println("第" + (i+1) + "本书共有" + attrs.getLength() + "个属性"); //遍历book的属性 for(int j = 0; j &lt; attrs.getLength(); j++)&#123; //通过item(index)方法获取book节点某一个属性 Node attr = attrs.item(j); //获取属性名 System.out.print("属性名：" + attr.getNodeName()); //获取属性值 System.err.println("--属性值：" + attr.getNodeValue()); &#125; /*//前提：已经知道book节点有且只能有1个id属性 //将book节点进行强制类型转换，转换成Element类型 Element book = (Element)bookList.item(i); //通过getAttribute("id")方法获取属性值 String attrVal = book.getAttribute("id"); System.out.println("id的属性值为：" + attrVal);*/ //解析book节点的子节点 NodeList childNodes = book.getChildNodes(); //遍历childNodes获取每个节点的节点名和节点值 System.out.println("第" + (i+1) + "本书共有" + childNodes.getLength() + "个子节点"); for(int k = 0; k &lt; childNodes.getLength(); k++)&#123; //区分出text类型的node以及element类型的node if(childNodes.item(k).getNodeType() == Node.ELEMENT_NODE)&#123; //获取了element类型的节点名 System.out.print("第" + (k+1) + "个节点的节点名：" + childNodes.item(k).getNodeName()); //获取了element类型的节点值// System.out.println("--节点值：" + childNodes.item(k).getFirstChild().getNodeValue()); System.out.println("--节点值：" + childNodes.item(k).getTextContent()); &#125; &#125; System.out.println("===下面结束遍历第" + (i+1) + "本书的内容==="); &#125; &#125; catch (ParserConfigurationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SAXException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#字符串类型转换]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[string 类型转成 byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes(str); byte[] 转成 string1string str = System.Text.Encoding.Default.GetString(byteArray); string 类型转成 ASCII byte[] (“01” 转成 byte[] = new byte[]{0x30,0x31}) 1byte[] byteArray = System.Text.Encoding.ASCII.GetBytes(str); ASCIIbyte[] 转成 string** (byte[] = new byte[]{0x30,0x31} 转成 “01”) 1string str = System.Text.Encoding.ASCII.GetString(byteArray); byte[] 转16进制格式 string new byte[]{0x30,0x31} 转成 “3031” 1234567891011121314public static string ToHexString(byte[] bytes) //0xae00cf =&gt; "AE00CF"&#123; string hexString = string.Empty; if(bytes != null) &#123; StringBuilder strB = new StringBuilder(); for(int i = 0; i &lt; bytes.Length; i++) &#123; strB.Append(bytes[i].ToString("x2")); &#125; hexString = strB.ToString(); &#125; return hexString;&#125; 16进制格式 string 转 byte[]123456789101112131415161718192021222324252627282930public static byte[] GetBytes(string hexString, out int discarded)&#123; discarded = 0; string newString = ""; char c; //remove all none A-F, 0-9, characters for(int i = 0; i &lt; hexString.Length; i++) &#123; c = hexString[i]; if(IsHexDig(c)) new String += c; else discarded++; &#125; //if odd number of characters,discard last character if(newString.Length % 2 != 0) &#123; discarded++; newString = newString.Substring(0, newString.Length - 1); &#125; int byteLength = newString.Length / 2; byte[] bytes = new byte[byteLength]; string hex; int j = 0; for(int i = 0; i &lt; bytes.Length; i++) &#123; hex = new String(new Char[]&#123;newString[j], newString[j + 1]&#125;); bytes[i] = HexToByte(hex); j = j + 2; &#125; return bytes;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#托盘操作]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E6%89%98%E7%9B%98%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[最小化到托盘 添加 NotifyIcon 控件 设置 NotifyIcon 控件的 Icon 属性，用来显示托盘区的图标 代码部分 12345678910111213141516171819private void Form1_Resize(object sender, EventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Hide(); this.ShowInTaskbar = false; this.notifyIcon1.Visible = true; &#125;&#125;private void notifyIcon1_MouseDoubleClick(object sender, MouseEventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Show(); this.ShowInTaskbar = true; this.notifyIcon1.Visible = false; &#125;&#125; 托盘区右键菜单栏 添加 ContextMenuStrip 控件 添加项 设置菜单项的事件 将 ContextMenuStrip 控件绑定到 NotifyIcon 控件上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剪贴板复制粘贴操作]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[复制12string str = "要复制的内容";Clipboard.SetDataObject(str); 粘贴12345IDataObject ido = Clipboard.GetDataObject();if(ido.Data.GetDataPresent(DataFormats.Text))&#123; txt_content.Text = (String)ido.GetData(DataFormats.Text);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象序列化和反序列化]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[对象序列化和反序列化 对象序列化就是将Object转换成byte序列，反之叫反序列化 序列化流ObjectOutputStream是过滤流—-writeObject(obj) 反序列化流ObjectInputStream—readObject() 要序列化的对象必须实现序列化接口，才能进行序列化，否则将出现异常，这个接口没有任何方法，只是一个标准 被transient关键字修饰的变量，不会进行jvm默认的序列化，但可以自己完成这个元素的序列化 private transient int sutAge; 参考ArrayList类中被transient修饰变量的序列化实现，可理解transient的作用，提高性能，避免无效元素的序列化 如果一个类实现了序列化接口，那么其子类都可以进行序列化 序列化子类对象时，父类和子类的构造函数会被调用 反序列化子类对象时，没有实现序列化接口的父类会调用构造函数，实现了序列化接口的父类不会调用 要序列化的对象12345678910111213141516171819202122232425262728public class Student implements Serializable&#123; private String stuName; private String stuId; private int stuAge; //无参构造方法 public Student()&#123; &#125; //带参构造方法 public Student(String stuName, String stuId, int stuAge) &#123; super(); this.stuName = stuName; this.stuId = stuId; this.stuAge = stuAge; &#125; //get和set方法 public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; //...省略 //toString()方法 @Override public String toString() &#123; return "Student [stuName=" + stuName + ", stuId=" + stuId + ", stuAge=" + stuAge + "]"; &#125;&#125; 序列化实现12345678910111213141516public static void main(String[] args)throws Exception &#123; Student stu = new Student("张三", "10010", 20); String file = "ObjSeria.dat"; //序列化 /*ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(file)); oos.writeObject(stu); oos.flush(); oos.close();*/ //反序列化 ObjectInputStream ois = new ObjectInputStream( new FileInputStream(file)); Student stu1 = (Student)ois.readObject(); System.out.println(stu1); ois.close();&#125; 序列化和反序列化被transient关键字修饰的变量12345678910111213//将这两个方法放入要序列化的类中private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; s.defaultWriteObject();//把jvm能默认序列化的元素进行序列化操作 s.writeInt(stuAge);//自己完成stuAge的序列化&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException&#123; s.defaultReadObject();//把jvm能默认反序列化的元素进行反序列化操作 this.stuAge = s.readInt();//自己完成stuAge的反序列化&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F03%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
