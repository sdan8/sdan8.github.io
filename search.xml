<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[C#字符串类型转换]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[string 类型转成 byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes(str); byte[] 转成 string1string str = System.Text.Encoding.Default.GetString(byteArray); string 类型转成 ASCII byte[] (“01” 转成 byte[] = new byte[]{0x30,0x31}) 1byte[] byteArray = System.Text.Encoding.ASCII.GetBytes(str); ASCIIbyte[] 转成 string** (byte[] = new byte[]{0x30,0x31} 转成 “01”) 1string str = System.Text.Encoding.ASCII.GetString(byteArray); byte[] 转16进制格式 string new byte[]{0x30,0x31} 转成 “3031” 1234567891011121314public static string ToHexString(byte[] bytes) //0xae00cf =&gt; "AE00CF"&#123; string hexString = string.Empty; if(bytes != null) &#123; StringBuilder strB = new StringBuilder(); for(int i = 0; i &lt; bytes.Length; i++) &#123; strB.Append(bytes[i].ToString("x2")); &#125; hexString = strB.ToString(); &#125; return hexString;&#125; 16进制格式 string 转 byte[]123456789101112131415161718192021222324252627282930public static byte[] GetBytes(string hexString, out int discarded)&#123; discarded = 0; string newString = ""; char c; //remove all none A-F, 0-9, characters for(int i = 0; i &lt; hexString.Length; i++) &#123; c = hexString[i]; if(IsHexDig(c)) new String += c; else discarded++; &#125; //if odd number of characters,discard last character if(newString.Length % 2 != 0) &#123; discarded++; newString = newString.Substring(0, newString.Length - 1); &#125; int byteLength = newString.Length / 2; byte[] bytes = new byte[byteLength]; string hex; int j = 0; for(int i = 0; i &lt; bytes.Length; i++) &#123; hex = new String(new Char[]&#123;newString[j], newString[j + 1]&#125;); bytes[i] = HexToByte(hex); j = j + 2; &#125; return bytes;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C#托盘操作]]></title>
      <url>%2F2016%2F12%2F03%2FC-%E6%89%98%E7%9B%98%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[最小化到托盘 添加 NotifyIcon 控件 设置 NotifyIcon 控件的 Icon 属性，用来显示托盘区的图标 代码部分 12345678910111213141516171819private void Form1_Resize(object sender, EventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Hide(); this.ShowInTaskbar = false; this.notifyIcon1.Visible = true; &#125;&#125;private void notifyIcon1_MouseDoubleClick(object sender, MouseEventArgs e)&#123; if(this.WindowState == FormWindowState.Minimized) &#123; this.Show(); this.ShowInTaskbar = true; this.notifyIcon1.Visible = false; &#125;&#125; 托盘区右键菜单栏 添加 ContextMenuStrip 控件 添加项 设置菜单项的事件 将 ContextMenuStrip 控件绑定到 NotifyIcon 控件上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剪贴板复制粘贴操作]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[复制12string str = "要复制的内容";Clipboard.SetDataObject(str); 粘贴12345IDataObject ido = Clipboard.GetDataObject();if(ido.Data.GetDataPresent(DataFormats.Text))&#123; txt_content.Text = (String)ido.GetData(DataFormats.Text);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象序列化和反序列化]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[对象序列化和反序列化 对象序列化就是将Object转换成byte序列，反之叫反序列化 序列化流ObjectOutputStream是过滤流—-writeObject(obj) 反序列化流ObjectInputStream—readObject() 要序列化的对象必须实现序列化接口，才能进行序列化，否则将出现异常，这个接口没有任何方法，只是一个标准 被transient关键字修饰的变量，不会进行jvm默认的序列化，但可以自己完成这个元素的序列化 private transient int sutAge; 参考ArrayList类中被transient修饰变量的序列化实现，可理解transient的作用，提高性能，避免无效元素的序列化 如果一个类实现了序列化接口，那么其子类都可以进行序列化 序列化子类对象时，父类和子类的构造函数会被调用 反序列化子类对象时，没有实现序列化接口的父类会调用构造函数，实现了序列化接口的父类不会调用 要序列化的对象12345678910111213141516171819202122232425262728public class Student implements Serializable&#123; private String stuName; private String stuId; private int stuAge; //无参构造方法 public Student()&#123; &#125; //带参构造方法 public Student(String stuName, String stuId, int stuAge) &#123; super(); this.stuName = stuName; this.stuId = stuId; this.stuAge = stuAge; &#125; //get和set方法 public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; //...省略 //toString()方法 @Override public String toString() &#123; return "Student [stuName=" + stuName + ", stuId=" + stuId + ", stuAge=" + stuAge + "]"; &#125;&#125; 序列化实现12345678910111213141516public static void main(String[] args)throws Exception &#123; Student stu = new Student("张三", "10010", 20); String file = "ObjSeria.dat"; //序列化 /*ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(file)); oos.writeObject(stu); oos.flush(); oos.close();*/ //反序列化 ObjectInputStream ois = new ObjectInputStream( new FileInputStream(file)); Student stu1 = (Student)ois.readObject(); System.out.println(stu1); ois.close();&#125; 序列化和反序列化被transient关键字修饰的变量12345678910111213//将这两个方法放入要序列化的类中private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; s.defaultWriteObject();//把jvm能默认序列化的元素进行序列化操作 s.writeInt(stuAge);//自己完成stuAge的序列化&#125;private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException&#123; s.defaultReadObject();//把jvm能默认反序列化的元素进行反序列化操作 this.stuAge = s.readInt();//自己完成stuAge的反序列化&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F03%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
